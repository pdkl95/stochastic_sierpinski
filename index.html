<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Stochastic Sierpinski</title>
    <style type="text/css" media="screen">
* {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
* html {
  font-size: 75%;
}

html {
  font-size: 100%;
  line-height: 16px;
  overflow-y: scroll;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
  font-family: Ubuntu, sans-serif;
  font-family: Ubuntu, sans-serif;
  font-weight: 400;
  font-style: normal;
  text-transform: none;
  text-decoration: none;
  letter-spacing: 0em;
  word-spacing: 0em;
}

body {
  margin: 0.1rem 1rem;
  font-size: 12px;
  line-height: 16px;
}

pre, code, kbd, tt, select, input, textarea {
  font-family: "Ubuntu Mono", Inconsolata, Consolas, monospace;
  font-size: 13px;
}

pre {
  background-color: #eee;
  padding: 2px 5px;
  box-shadow: 1px 1px 4px -3px rgba(0, 0, 0, 0.4) inset;
  border: 1px inset rgba(200, 200, 200, 0.4);
  border-radius: 8px;
}

code {
  display: inline-block;
  background-color: #ececec;
  box-shadow: 0px 1px 7px 1px #fff inset;
  border-radius: 8px;
  margin: 0px -3px;
}

pre code {
  border-bottom: none;
  box-shadow: none;
  background: transparent;
  line-height: 16px;
  padding: 0px 3px;
}

h1 {
  color: #111;
  margin-bottom: 0.6rem;
  margin-left: -0.1rem;
  margin-top: 2.5rem;
  padding: 5px 0.5rem;
  background-color: #f2f2f2;
  border: 1px outset rgba(0, 0, 0, 0.3);
  box-shadow: 1px 1px 6px -3px rgba(0, 0, 0, 0.22), 0 0 20px -4px rgba(255, 255, 255, 0.45) inset;
  border-radius: 5px 5px 5px 5px;
}
h1:first-top {
  margin-top: 0.5rem;
}
h1 + pre, h1 + p {
  margin-top: 1rem;
}
h1 + h2 {
  margin-top: 0.4rem;
}

h2 {
  margin-top: 1.6rem;
  margin-bottom: 0.5rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  padding-bottom: 1px;
}
h2 > code {
  background: transparent;
  box-shadow: none;
}

h3 {
  margin-top: 1.6rem;
  margin-bottom: 0.5rem;
  margin-top: 0.6rem;
  margin-left: 2rem;
  margin-bottom: 0.2rem;
}
h3 > code {
  background: transparent;
  box-shadow: none;
}

h4, h5, h6 {
  margin-left: 2rem;
}

h5 {
  padding-left: 0.2em;
  margin-bottom: 0;
}

h3 {
  margin-top: 1.5rem;
  margin-bottom: 1.4rem;
  padding: 0;
  margin-bottom: 0;
}

h4, h6 {
  padding: 0;
  margin-bottom: 0;
}

p, pre, table {
  margin-left: 2rem;
  margin-right: 2rem;
  margin-top: 0;
  margin-bottom: 1rem;
}

h5 {
  padding-left: 5px;
}

ol, ul {
  list-style-position: inside;
  margin-left: 0;
  padding-left: 2rem;
}

li {
  padding-left: 0;
}
li > p {
  display: inline;
  margin: 0;
  padding: 0;
}

a {
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}

li > h2 {
  margin: 0;
}

p {
  color: #444;
}

.hidden {
  display: none;
}

body > footer {
  margin-top: 8em;
}


    </style>
    <style type="text/css" media="screen" title="app_stylesheet">
body {
  background: #bbb;
}

h1 {
  margin-top: 0.666rem;
  padding-top: 7px;
  padding-bottom: 7px;
}

#debugbox {
  color: #0F0;
  background: #000;
  border-radius: 6px;
  margin-left: 0;
  margin-right: 0;
  padding: 0;
}

#debugbox .hdr {
  display: inline-block;
  background-color: #040;
  text-shadow: 0px 0px 2px rgb(0, 0, 0);
  border-right: 1px dotted #0F0;
  padding: 2px 5px;
  margin-right: 8px;
}

#debugbox .msg {
  display: inline-block;
  padding: 2px 5px;
}

.panel {
  border: 1px outset rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  background-color: #F2F2F2;
  padding: 4px;
}

#content > .graph.panel {
}

.graph_canvas {
  position: absolute;
  top: 0;
  left: 0;
}

.canvas_size {
  width: 420px;
  height: 420px;
}

.canvas_wrapper {
  background-color: #fff;
  border-radius: 3px;
  border: 1px inset rgba(0, 0, 0, 0.3);
  position: relative;
  overflow: hidden;
}

.clear_both {
  clear: both;
}

.resizable {
  resize: both;
}

.center {
  text-align: center;
}

.right {
  text-align: right;
}

.panel {
  box-shadow: 1px 1px 6px -3px rgba(0, 0, 0, 0.22), 0 0 20px -4px rgba(255, 255, 255, 0.45) inset;
}

.graph.panel {
  float: left;
  margin-right: 7px;
  padding: 4px;
}

.info.panel {
  float: left;
}

.graph.panel,
.info.panel {
  margin-bottom: 7px;
}

.info.panel > table {
  margin-left: 7px;
  margin-right: 7px;
  margin-bottom: 0px;
}

.ui.panel {
  clear: both;
}

footer {
  clear: both;
}

.panel tr > th:first-child {
  text-align: right;
  padding-right: 0.4em;
}


.ui.panel > .buttonbox {
  display: inline-block;
}

.buttonbox > .title {
  display: inline-block;
  position: relative;
  top: -1px;
  margin-left: 1em;
  margin-right: 0.333em;
}

.buttonbox > .title:first-child {
  font-weight: bold;
  margin-left: 0em;
  margin-right: 1em;
}

.buttonbox.bbright {
  float: right;
}

.buttonbox.bbright ~ hr {\
  margin-top: 4px;
  margin-bottom: 4px;
  opacity: 0.15;
}

.buttonbox > label + label {
  margin-left: 1em;
}

.buttonbox.uioptbox > label {
  position: relative;
  top: -1px;
}

.buttonbox input[type="checkbox"] {
  position: relative;
  top: 2px;
}

.optionbox {
}

.optionbox.obleft {
  float: left;
}

.optionbox.obright {
  float: right;
}

.optionbox > h3 {
  float: left;
  margin-left: 0.2rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  border: 1px outset #bbb;
  border-radius: 3px;
  padding: 2px 5px;
  background-color: #ccc
}

.optionbox > table {
  clear: left;
  margin-left: 0.5rem;
}

.ui.panel > hr ~ h3 {
  margin-top: 0.5rem;
}

.restrictbox {
  overflow-x: auto;
}

#restrict_table {
  border-spacing: 0;
}

#restrict_table th {
  padding: 3px;
  text-align: center;
}

#restrict_table td {
  padding: 3px;
  text-align: center;
}

#restrict_table th[scope="row"] {
  text-align: right;
}

#restrict_table .self,
#restrict_table .opposite {
  background-color: #e2e2e2
}

#restrict_table .styled_checkbox_container {
  display: block;
  position: relative;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  margin: 0 4px;
}

#restrict_table .styled_checkbox_container .hidden_checkbox {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

#restrict_table .styled_checkbox_container .checkmark {
  position: absolute;
  top: 0;
  left: 0;
  border-radius: 4px;
}

#restrict_table .styled_checkbox_container,
#restrict_table .styled_checkbox_container .checkmark {
  height: 1.2rem;
  width:  1.2rem;
}

#restrict_table .styled_checkbox_container .hidden_checkbox ~ .checkmark.inactive {
  display: block;
  background-color: #2a2;
  border: 1px outset #147214;
  box-shadow: 1px 1px 2px -1px #000;
}

#restrict_table .styled_checkbox_container .hidden_checkbox ~ .checkmark.active {
  display: none;
}

#restrict_table .styled_checkbox_container .hidden_checkbox:checked ~ .checkmark.inactive {
  display: none;
}

#restrict_table .styled_checkbox_container .hidden_checkbox:checked ~ .checkmark.active {
  display: block;
  color: #eee;
  background-color: #a22;
  border: 1px inset #681515;
  box-shadow: 1px 1px 2px -1px #000 inset;
  text-align: center;
  font-family: monospace;
  font-size: 12px;
  line-height: 12px;
}

#restrict_table .styled_checkbox_container:hover .hidden_checkbox ~ .checkmark.inactive {
  border-style: solid;
  border-color: #681515;
}

#restrict_table .styled_checkbox_container:hover .hidden_checkbox:checked ~ .checkmark.active {
  border-style: solid;
  border-color: #147214;
}

#restrict_table .styled_checkbox_container .hidden_checkbox:disabled ~ .checkmark {
  opacity: 0.333;
  border-style: solid;
  border-color: #F2F2F2;
  box-shadow: none;
}

#imgmask_img_box {
  float: right;
}

td.blank {
  border: none;
}

#button_run {
  min-width: 4.5em;
}

#num_points {
  width: 3em;
}

#canvas_width,
#canvas_height {
  width: 5em;
}

#set_all_points_box {
  padding-right: 0;
}

#set_all_points {
  font-weight: bold;
  padding-left: 1px;
  padding-right: 1px;
}

#move_range_max_label {
  margin-left: 0.5em;
}

#move_range_min,
#move_range_max {
  width: 3em;
}

.imgmask_caption_size_hw {
  margin-left: 0.3em;
  font-weight: light;
}

.imgmask_caption_size_hw > code {
  font-weight: normal;
}

#imgmask_img_box > figure {
  display: inline-block;
  margin: 0;
}
#imgmask_img_box > figure ~ figure {
  margin-left: 1em;
}

#imgmask_img_box > figure > figcaption {
  font-weight: bold;
}

#imgmask_img_box > figure > img,
#imgmask_img_box > figure > canvas {
  width: 96px;
  height: 96px;
  padding: 3px;
  border-radius: 3px;
  border: 1px inset rgba(0, 0, 0, 0.3);
  box-shadow: 0 0 3px -1px rgba(0, 0, 0, 0.5) inset;
  background-color: #ccc;
}

#imgmask_scale_width ~ label {
  margin-left: 1em;
}

#imgmask_scale_width,
#imgmask_scale_height,
#imgmask_offset_x,
#imgmask_offset_y,
#imgmask_oversample,
#steps_per_frame,
#draw_opacity {
  width: 3.5em;
}

#all_points_table {
  float: right;
}

#point_pos_table input[type="color"] {
  width: 3em;
}

#point_pos_table input[type="number"],
#all_points_table input[type="number"] {
  width: 4em;
}

#point_pos_table input[type="range"],
#all_points_table input[type="range"] {
  width: 8em;
  margin-left: 0;
  margin-right: 0;
}

#point_pos_table td:nth-child(3),
#point_pos_table td:nth-child(4),
#point_pos_table td:nth-child(5) {
  text-align: right;
}

th.move_mode,
td.move_mode {
  width: 24px;
  text-align: center;
}

#point_pos_table .move_mode input[type="checkbox"] {
  margin-left: 0;
  margin-right: 0;
}

.highlight > td {
  background-color: #F9FBB6;
}

.highlight > td:first-child {
  font-weight: bold;
}

#serializebox {
  display: none;
  position: fixed;
  top: 6em;
  left: 4em;
  border-radius: 8px;
  border: 2px outset rgba(0, 0, 0, 0.5);
  padding: 1em;
  min-width: 50%;
  background: #ddd;
}

#serializebox_title {
  margin-top: 0;
  margin-left: 0;
  margin-bottom: 0.666em;
}

#serializebox_text {
  width: 100%;
  min-height: 8em;
}

#serializebox > .ui.panel {
  text-align: right;
}

.tt {
  position: relative;
}

.tt::before {
   content: attr(data-title);
   display: none;
   position: absolute;
   width: 240px;
   z-index: 2;

   padding: 3px 5px;
   text-align: left;
   background-color: #f4f4f4;
   border: 2px solid #222;
   border-radius: 6px;
}

.tt.ttleft::before {
   top: 165%;
   right: 0;
}

.tt.ttright::before {
   top: 165%;
   left: 0;
}

.tt.ttleft::after {
  content: " ";
  display: none;
  position: absolute;
  z-index: 1;
  bottom: -12px;
  left: 50%;
  margin-top: -8px;
  border-width: 8px;
  border-style: solid;
  border-color: transparent transparent #222 transparent;
}

.tt.ttright::after {
  content: " ";
  display: none;
  position: absolute;
  z-index: 1;
  bottom: -12px;
  left: 50%;
  margin-top: -8px;
  border-width: 8px;
  border-style: solid;
  border-color: transparent transparent #222 transparent;
}

.show_tt .tt:hover::before,
.show_tt .tt.ttleft:hover::after,
.show_tt .tt.ttright:hover::after {
  display: block;
}

    </style>
  </head>
  <body>
    <header>
      <h1>Stochastic Sierpinski</h1>
    </header>

    <pre id="debugbox" class="hidden"><span class="hdr"></span><span class="msg"></span></pre>

    <div id="content" class="show_tt">
      <div class="graph panel">
        <div id="graph_wrapper" class="canvas_wrapper canvas_size">
          <canvas id="graph" class="graph_canvas canvas_size" width="420" height="420">
            This requires a browser that supports the &lt;canvas&gt; tag.
          </canvas>
          <canvas id="graph_ui" class="graph_canvas canvas_size" width="420" height="420">
            This requires a browser that supports the &lt;canvas&gt; tag.
          </canvas>
        </div>
      </div>

      <div class="info panel">
        <table id="all_points_table">
          <tr>
            <td colspan=3 class="right">
              <label for="move_range_min">MIN</label>
              <input id="move_range_min" name="move_range_min"
                     type="number" value="0" step="1">
              <label for="move_range_max" id="move_range_max_label">MAX</label>
              <input id="move_range_max" name="move_range_max"
                     type="number" value="100" step="1">
            </td>
          </tr>
          <tr>
            <td>
              <input type="number" id="all_points_move_perc_option" value=50>
            </td>
            <td>
              <input type="range" id="all_points_move_perc_range"
                     min="0" max="100" step="5" value="50">
            </td>
            <td class="move_mode" id="set_all_points_box">
              <button id="set_all_points">&darr;</button>
            </td>
          </tr>
        </table>
        <table id="misc_info_table">
          <tr>
            <th>Current X,Y</th>
            <td id="point_cur_x"></td>
            <td id="point_cur_y"></td>
          </tr>
          <tr>
            <th>Total Steps</th>
            <td id="total_steps" colspan=2></td>
          </tr>
        </table>
        <table id="point_pos_table">
          <tr>
            <th>P</th>
            <th>Color</th>
            <th>X</th>
            <th>Y</th>
            <th>Move %</th>
            <th colspan=2 class="right">Rel?</th>
          </tr>
        </table>
      </div>

      <div class="ui panel">
        <div class="runbox buttonbox">
          <button id="button_reset" class="tt ttright" data-title="Reset back to a blank canvas.">Reset</button>
          <button id="button_step" class="tt ttright" data-title="One step of the chaos game. Selects a random point, moves toward it, and draws a point.">Step 1x</button>
          <button id="button_multistep" class="tt ttright" data-title="Run a fixed number of steps. The number of steps can be changed with the 'Steps / Frame' option.">Step Nx</button>
          <button id="button_run" class="tt ttright" data-title="Draws 'Steps / Frame' points every frame until manually stopped by pressing Pause or Step">Run</button>
        </div>

        <div class="pointsbox buttonbox bbright">
          <span class="title">Points</span>
          <label for="num_points">
            N =
            <input type="number" id="num_points" value="3"
                   min="3" max="8" step="1">
          </label>
          <span class="title">Move All</span>
          <button id="move_all_reg_polygon" class="tt ttleft" data-title="Move all points into the corners of an N-sided regullar polygon.">Reg. Polygon</button>
          <button id="move_all_random" class="tt ttleft" data-title="Move all points to random positions.">Random</button>
        </div>

        <hr class="clear_both">

        <div class="imgbox buttonbox">
          <button id="button_create_png" class="tt ttright" data-title="Open the current canvas image as a PNG file in a new tab/window.">Create PNG</button>
          <button id="button_save_url" class="tt ttright" data-title="Saves the current settings to the hash (#) on the current URL">Save as URL</button>
          <button id="button_save" class="tt ttright" data-title="Saves the current settings to copy-able JSON-formatted text.">Save as JSON</button>
          <button id="button_load" class="tt ttright" data-title="Paste the JSON-formatted text (from 'Save as JSON') to load previously saves settings.">Load from JSON</button>
        </div>

        <div class="uioptbox buttonbox bbright">
          <span class="title tt ttleft" data-title="User-Interface Options. These options do not affect the drawing results, so they are not saved with the other option. Instead, they are saved in a browser cookie.">UI Options</span>
          <label for="show_tooltips" class="tt ttleft" data-title="Enable/Disable tooltips similar tol what you are reading right now.">
            Show Tooltips
            <input id="show_tooltips" type="checkbox" checked="checked">
          </label>
          <label for="steps_per_frame" class="tt ttleft" data-title="The number of steps that are computed each frame. Higher values render fast at the cost of greater CPU load.">
            Steps / Frame
            <input type="number" id="steps_per_frame" min="0" max="500" step="10">
          </label>
        </div>

        <hr class="clear_both">

        <div class="optionsbox optionbox obright">
          <h3>Draw Options</h3>
          <table>
            <tr>
              <th>Canvas Size</th>
              <td>
                <input id="canvas_width" type="number" value="420"
                       min="64" max="4096" step="1">
                &nbsp;x&nbsp;
                <input id="canvas_height" type="number" value="420"
                       min="64" max="4096" step="1">
              </td>
            </tr>
            <tr>
              <th>Draw Opacity</th>
              <td><input id="draw_opacity" type="number"
                         min="0" max="100" step="5">%</td>
            </tr>
            <tr>
              <th>Draw Style</th>
              <td>
                <select id="draw_style" name="draw_style">
                  <option value="mono">Monochrome (black on white)</option>
                  <option value="color_target">Target Point's Color</option>
                  <option value="color_blend_prev_target">blend(target, prev_target)</option>
                  <option value="color_blend_prev_color">blend(target, prev_blend)</option>
                </select>
              </td>
            </tr>
            <tr>
              <th>Data Source</th>
              <td>
                <select id="movement_data_source" name="movement_data_source">
                  <option value="dest">Destination</option>
                  <option value="orig">Origin</option>
                </select>
              </td>
            </tr>
          </table>
        </div>

        <div class="restrictbox optionbox obleft">
          <h3>Random Target Restrictions</h3>
          <table id="restrict_table">
            <tr>
              <td class="blank"></td>
              <th scope="col" class="header prev prev3">-3</th>
              <th scope="col" class="header prev prev2">-2</th>
              <th scope="col" class="header prev prev1">-1</th>
              <th scope="col" class="header self">Self</th>
              <th scope="col" class="header next next1">+1</th>
              <th scope="col" class="header next next2">+2</th>
              <th scope="col" class="header next next3">+3</th>
              <th scope="col" class="header opposite">Opp</th>
            </tr>
            <tr>
              <th scope="row">Last</th>
              <td class="single prev prev3"><input type="checkbox" id="restrict_single_prev_3"></td>
              <td class="single prev prev2"><input type="checkbox" id="restrict_single_prev_2"></td>
              <td class="single prev prev1"><input type="checkbox" id="restrict_single_prev_1"></td>
              <td class="single self">      <input type="checkbox" id="restrict_single_self"></td>
              <td class="single next next1"><input type="checkbox" id="restrict_single_next_1"></td>
              <td class="single next next2"><input type="checkbox" id="restrict_single_next_2"></td>
              <td class="single next next3"><input type="checkbox" id="restrict_single_next_3"></td>
              <td class="single opposite">  <input type="checkbox" id="restrict_single_opposite"></td>
            </tr>
            <tr>
              <th scope="row" class="double">Last 2x</th> 
              <td class="double prev prev3"><input type="checkbox" id="restrict_double_prev_3"></td>
              <td class="double prev prev2"><input type="checkbox" id="restrict_double_prev_2"></td>
              <td class="double prev prev1"><input type="checkbox" id="restrict_double_prev_1"></td>
              <td class="double self">      <input type="checkbox" id="restrict_double_self"></td>
              <td class="double next next1"><input type="checkbox" id="restrict_double_next_1"></td>
              <td class="double next next2"><input type="checkbox" id="restrict_double_next_2"></td>
              <td class="double next next3"><input type="checkbox" id="restrict_double_next_3"></td>
              <td class="double opposite">  <input type="checkbox" id="restrict_double_opposite"></td>
            </tr>
          </table>
        </div>

        <div class="clear_both"></div>

        <div id="imgmask_img_box" class="imgmask_img_hide optionbox obright hidden">
          <h3>Masked Location Bitmap</h3>
          <figure>
            <figcaption id="imgmask_img_caption">
              Original
              <br>
              <span class="imgmask_caption_size_hw">
                <code id="imgmask_img_size_width"></code>
                &nbsp;x&nbsp;
                <code id="imgmask_img_size_height"></code>
              </span>
            </figcaption>
          </figure>
          <figure>
            <figcaption id="imgmask_bitmap_caption">
              Bitmap
              <br>
              <span class="imgmask_caption_size_hw">
                <code id="imgmask_bitmap_size_width"></code>
                &nbsp;x&nbsp;
                <code id="imgmask_bitmap_size_height"></code>
              </span>
            </figcaption>
          </figure>
        </div>

        <div class="imgmaskbox optionbox obleft">
          <h3>Restricted Location Bitmap</h3>
          <table>
            <tr>
              <th>Enabled?</th>
              <td><input id="imgmask_enabled" type="checkbox"></td>
              <td></td>
            </tr>
            <tr>
              <th>Load Image As Bitmap</th>
              <td><input id="imgmask_file" type="file" accept="image/*"></td>
              <td>
              </td>
            </tr>
            <tr>
              <th>Bitmap Threshold</th>
              <td><input id="imgmask_threshold" type="range" value="1"
                         min="1" max="254" step="1">%</td>
              <td></td>
            </tr>
            <tr>
              <th>Bitmap Size</th>
              <td>
                <label for="imgmask_scale_width">L/R</label>
                <input id="imgmask_scale_width"
                       name="imgmask_scale_width"
                       type="number" value="50"
                       min="0" max="99" step="1">&nbsp;%
                <label for="imgmask_scale_height">T/B</label>
                <input id="imgmask_scale_height"
                       name="imgmask_scale_height"
                       type="number" value="50"
                       min="0" max="99" step="1">&nbsp;%
              </td>
              <td></td>
            </tr>
            <tr>
              <th>Bitmap Offset</th>
              <td>
                <label for="imgmask_offset_x">X</label>
                <input id="imgmask_offset_x" name="imgmask_offset_x"
                       type="number" value="0" step="1">
                <label for="imgmask_offset_y">Y</label>
                <input id="imgmask_offset_y" name="imgmask_offset_y"
                       type="number" value="0" step="1">
              </td>
              <td></td>
            </tr>
            <tr>
              <th>Bitmap Oversampling</th>
              <td><input id="imgmask_oversample" type="number"
                         value="1" min="1" max="4" step="1">&nbsp;x
              <td>
              </td>
            </tr>
          </table>
        </div>

        <div class="clear_both"></div>
      </div>

      <div id="serializebox">
        <h3 id="serializebox_title" class="panel">Title</h3>
        <textarea id="serializebox_text"></textarea>
        <div class="ui panel">
          <div class="actionbuttons buttonbox">
            <button id="serializebox_action">Unknown Action</button>
            <button id="serializebox_cancel">Cancel</button>          
          </div>
        </div>
      </div>
    </div>

    <footer></footer>

    <script type="text/javascript">
(function() {
  var APP, BoolUIOption, Color, DNDHandler, DrawPoint, EnumUIOption, MultiDNDHandler, NumberUIOption, OffsetDNDHandler, Point, PointWidget, ScaleDNDHandler, ScaleHeightDNDHandler, ScaleWidthDNDHandler, StochasticSierpinski, TargetRestriction, TargetRestrictionOption, UIOption, UIPoint, XOffsetDNDHandler, YOffsetDNDHandler, base,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  APP = null;

  if ((base = Array.prototype).flatten == null) {
    base.flatten = function() {
      var el, j, len1, ref, result;
      result = [];
      ref = this;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        el = ref[j];
        if (el instanceof Array) {
          result = result.concat(el.flatten());
        } else {
          result.push(el);
        }
      }
      return result;
    };
  }

  Array.prototype.shuffle = function() {
    return this.slice(0).reduceRight((function(r, _, __, s) {
      r.push(s.splice(0 | Math.random() * s.length, 1)[0]);
      return r;
    }), []);
  };

  if (Math.TAU == null) {
    Math.TAU = 2 * Math.PI;
  }

  if (Object.values == null) {
    Object.values = function(obj) {
      return Object.keys(obj).map(function(x) {
        return obj[x];
      });
    };
  }

  Color = (function() {
    function Color() {}

    Color.hsl_to_rgb = function(h, s, l) {
      var m1, m2;
      m2 = l <= 0.5 ? l * (s + 1) : l + s - (l * s);
      m1 = (l * 2) - m2;
      return [Color.hue_to_rgb(m1, m2, h + (1 / 3)), Color.hue_to_rgb(m1, m2, h), Color.hue_to_rgb(m1, m2, h - (1 / 3))];
    };

    Color.hue_to_rgb = function(m1, m2, h) {
      if (h < 0) {
        h = h + 1;
      }
      if (h > 1) {
        h = h - 1;
      }
      if (h * 6 < 1) {
        return m1 + ((m2 - m1) * h * 6);
      }
      if (h * 2 < 1) {
        return m2;
      }
      if (h * 3 < 2) {
        return m1 + ((m2 - m1) * ((2 / 3) - h) * 6);
      }
      return m1;
    };

    Color.component_to_hex = function(x) {
      var str;
      str = Math.round(x * 255).toString(16);
      if (str.length === 1) {
        return '0' + str;
      } else {
        return str;
      }
    };

    Color.hsl_to_hexrgb = function() {
      var args, hex;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      hex = Color.hsl_to_rgb.apply(Color, args).map(Color.component_to_hex);
      return "#" + (hex.join(''));
    };

    Color.hexrgb_to_rgb = function(hexrgb) {
      var md;
      md = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexrgb);
      if (md) {
        return [parseInt(md[1], 16), parseInt(md[2], 16), parseInt(md[3], 16)];
      } else {
        return [0, 0, 0];
      }
    };

    Color.hexrgb_and_alpha_to_rgba_str = function(hexrgb, alpha) {
      var rgb;
      rgb = Color.hexrgb_to_rgb(hexrgb);
      return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + alpha + ")";
    };

    Color.rgb_to_hsl = function(rgb) {
      var b, cmax, cmin, delta, g, h, l, r, s;
      r = rgb[0] / 255;
      g = rgb[2] / 255;
      b = rgb[2] / 255;
      cmin = Math.min(r, g, b);
      cmax = Math.max(r, g, b);
      delta = cmax - cmin;
      h = delta === 0 ? 0 : cmax === r ? ((g - b) / delta) % 6 : cmax === g ? (b - r) / delta + 2 : (r - g) / delta + 4;
      h = Math.round(h * 60);
      if (h < 0) {
        h += 360;
      }
      l = (cmax + cmin) / 2;
      s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
      s = +(s * 100).toFixed(1);
      l = +(l * 100).toFixed(1);
      return [h, s, l];
    };

    Color.blend_rgb = function() {
      var args, len, total;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      total = args.reduce(function(acc, cur) {
        acc[0] += cur[0];
        acc[1] += cur[1];
        acc[2] += cur[2];
        return acc;
      });
      len = args.length;
      return [Math.floor(total[0] / len), Math.floor(total[1] / len), Math.floor(total[2] / len)];
    };

    Color.blend_hsl = function(a_hsl, b_hsl) {
      var ah, bh, h, hdelta;
      ah = a_hsl[0];
      bh = b_hsl[0];
      if (bh < ah) {
        bh += 360;
      }
      hdelta = bh - ah;
      h = ah + (hdelta / 2);
      if (h >= 360) {
        h -= 360;
      }
      return [h, Math.floor((a_hsl[1] + b_hsl[1]) / 2), Math.floor((a_hsl[2] + b_hsl[2]) / 2)];
    };

    Color.blend_hsl_from_rgb = function(a_rgb, b_rgb) {
      var a_hsl, b_hsl;
      a_hsl = Color.rgb_to_hsl(a_rgb);
      b_hsl = Color.rgb_to_hsl(b_rgb);
      return this.blend_hsl(a_hsl, b_hsl);
    };

    Color.srgb_to_linear = function(x) {
      x /= 255.0;
      if (x <= 0) {
        return 0;
      } else if (x >= 1) {
        return 1;
      } else if (x < 0.04045) {
        return x / 12.92;
      } else {
        return Math.pow((x + 0.055) / 1.055, 2.4);
      }
    };

    Color.linear_rgb_to_luminance = function(rl, gl, bl) {
      return (0.2126 * rl) + (0.7152 * gl) + (0.0722 * bl);
    };

    Color.srgb_to_luminance = function(r, g, b) {
      var bl, gl, rl;
      rl = Color.srgb_to_linear(r);
      gl = Color.srgb_to_linear(g);
      bl = Color.srgb_to_linear(b);
      return Color.linear_rgb_to_luminance(rl, gl, bl);
    };

    return Color;

  })();

  Point = (function() {
    function Point(name1, x, y, move_perc) {
      this.name = name1;
      this.move_perc = move_perc != null ? move_perc : APP.DEFAULT.move_perc;
      this.set_y = bind(this.set_y, this);
      this.set_x = bind(this.set_x, this);
      if (x == null) {
        x = APP.graph_ui_canvas.width / 2;
      }
      if (y == null) {
        y = APP.graph_ui_canvas.height / 2;
      }
      this.el_id = this.name.toLowerCase();
      this.info_x_id = 'point_' + this.el_id + '_x';
      this.info_y_id = 'point_' + this.el_id + '_y';
      this.move_perc_mode = true;
      this.build();
      this.move(x, y);
    }

    Point.prototype.build = function() {};

    Point.prototype.update_text = function() {
      if (this.info_x_cell) {
        this.info_x_cell.textContent = this.ix;
      }
      if (this.info_y_cell) {
        return this.info_y_cell.textContent = this.iy;
      }
    };

    Point.prototype.set_x = function(x) {
      this.x = x;
      return this.ix = Math.floor(this.x);
    };

    Point.prototype.set_y = function(y) {
      this.y = y;
      return this.iy = Math.floor(this.y);
    };

    Point.prototype.move_no_text_update = function(x, y) {
      this.x = x;
      this.y = y;
      this.ix = Math.floor(this.x);
      return this.iy = Math.floor(this.y);
    };

    Point.prototype.move_no_text_update_array = function(coord) {
      this.x = coord[0];
      this.y = coord[1];
      this.ix = Math.floor(this.x);
      return this.iy = Math.floor(this.y);
    };

    Point.prototype.move = function(x, y) {
      this.move_no_text_update(x, y);
      return this.update_text();
    };

    Point.prototype.move_perc_towards = function(target, perc) {
      var dx, dy;
      if (perc == null) {
        perc = target.move_perc;
      }
      dx = target.x - this.x;
      dy = target.y - this.y;
      return this.move(this.x + dx * perc, this.y + dy * perc);
    };

    Point.prototype.coords_after_move_perc_towards_target = function(target, perc) {
      var dx, dy;
      if (perc == null) {
        perc = target.move_perc;
      }
      dx = target.x - this.x;
      dy = target.y - this.y;
      return [this.x + dx * perc, this.y + dy * perc];
    };

    Point.prototype.move_perc_towards_no_text_update = function(target, perc) {
      if (perc == null) {
        perc = target.move_perc;
      }
      return this.move_no_text_update_array(this.coords_after_move_perc_towards_target(target, perc));
    };

    Point.prototype.coords_after_move_absolute_towards_target = function(target, dist) {
      var dx, dy, mag, norm_x, norm_y;
      if (dist == null) {
        dist = target.move_perc;
      }
      dist *= APP.move_absolute_magnitude;
      dx = target.x - this.x;
      dy = target.y - this.y;
      mag = Math.sqrt(dx * dx + dy * dy);
      norm_x = dx / mag;
      norm_y = dy / mag;
      return [this.x + norm_x * dist, this.y + norm_y * dist];
    };

    Point.prototype.move_absolute_towards_no_text_update = function(target, dist) {
      if (dist == null) {
        dist = target.move_perc;
      }
      return this.move_no_text_update_array(this.coords_after_move_absolute_towards_target(target, dist));
    };

    Point.prototype.distance = function(other) {
      var dx, dy;
      dx = this.x - other.x;
      dy = this.y - other.y;
      return Math.sqrt((dx * dx) + (dy * dy));
    };

    Point.prototype.scale_width = function(scale) {
      this.set_x(this.x * scale);
      return this.update_text();
    };

    Point.prototype.scale_height = function(scale) {
      this.set_y(this.y * scale);
      return this.update_text();
    };

    Point.prototype.scale = function(scale) {
      return this.scale_width(scale, origin);
    };

    return Point;

  })();

  UIPoint = (function(superClass) {
    extend(UIPoint, superClass);

    function UIPoint() {
      var args, hue;
      hue = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.on_move_per_range_input = bind(this.on_move_per_range_input, this);
      this.on_move_perc_option_change = bind(this.on_move_perc_option_change, this);
      this.set_color_hue(hue);
      UIPoint.__super__.constructor.apply(this, args);
    }

    UIPoint.prototype.update_color_alpha_from_color = function() {
      return this.set_opacity(APP.option.draw_opacity.value);
    };

    UIPoint.prototype.set_color_hue = function(hue) {
      return this.set_color(Color.hsl_to_hexrgb(hue / 360, 1.0, 0.5));
    };

    UIPoint.prototype.set_color = function(color) {
      var ref;
      this.color = color;
      this.update_color_alpha_from_color();
      return (ref = APP.cur) != null ? ref.reset_color_cache() : void 0;
    };

    UIPoint.prototype.set_alpha = function(alpha) {
      return this.color_alpha = Color.hexrgb_and_alpha_to_rgba_str(this.color, alpha);
    };

    UIPoint.prototype.set_opacity = function(opacity) {
      return this.set_alpha(opacity / 100);
    };

    UIPoint.prototype.draw_ui = function() {
      var ctx;
      ctx = APP.graph_ui_ctx;
      ctx.strokeStyle = this.color;
      return ctx.strokeRect(this.x - 2, this.y - 2, 5, 5);
    };

    UIPoint.prototype.move_perc_range_el_init = function() {
      this.set_move_range();
      this.move_perc_range_el.value = this.move_perc * 100;
      return this.move_perc_range_el.addEventListener('input', this.on_move_per_range_input);
    };

    UIPoint.prototype.set_move_range = function(min, max, step) {
      var value;
      if (min == null) {
        min = APP.option.move_range_min.get();
      }
      if (max == null) {
        max = APP.option.move_range_max.get();
      }
      if (step == null) {
        step = 5;
      }
      this.move_perc_range_el.min = min;
      this.move_perc_range_el.max = max;
      this.move_perc_range_el.step = step;
      if ((this.option != null) && (this.option.move_proc != null)) {
        value = this.option.move_proc.get();
        if (value < min) {
          value = min;
        }
        if (value > max) {
          value = max;
        }
        this.option.move_proc.set_range(min, max);
        return this.option.move_proc.set(value);
      }
    };

    UIPoint.prototype.on_move_perc_option_change = function(value) {
      this.set_move_perc(value);
      return APP.resumable_reset();
    };

    UIPoint.prototype.on_move_per_range_input = function(event) {
      this.set_move_perc(event.target.value);
      return APP.resumable_reset();
    };

    UIPoint.prototype.set_move_perc_range = function(newvalue) {
      var rounded, step;
      if (this.move_perc_range_el != null) {
        step = this.move_perc_range_el.step;
        rounded = Math.round(newvalue / step) * step;
        return this.move_perc_range_el.value = rounded;
      }
    };

    UIPoint.prototype.set_move_perc = function(newvalue) {
      this.move_perc = newvalue / 100.0;
      newvalue = this.move_perc * 100;
      this.option.move_perc.set(newvalue);
      return this.set_move_perc_range(newvalue);
    };

    UIPoint.prototype.set_move_perc_mode = function(newvalue) {
      this.move_perc_mode = newvalue;
      return this.option.move_perc_mode.set(this.move_perc_mode);
    };

    return UIPoint;

  })(Point);

  PointWidget = (function(superClass) {
    extend(PointWidget, superClass);

    PointWidget.is_name_used = function(name) {
      var j, len1, ref, w;
      ref = APP.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        w = ref[j];
        if (w.name === name) {
          return true;
        }
      }
      return false;
    };

    PointWidget.next_name = function() {
      var code, j, str;
      for (code = j = 65; j <= 90; code = ++j) {
        str = String.fromCharCode(code);
        if (!PointWidget.is_name_used(str)) {
          return str;
        }
      }
      alert('sorry, cannot generate more than 26 point names');
      throw 'cannot generate a unique point name';
    };

    PointWidget.create = function(opt) {
      if (opt == null) {
        opt = {};
      }
      if (opt.name == null) {
        opt.name = PointWidget.next_name();
      }
      if (opt.hue == null) {
        opt.hue = Math.random() * 360;
      }
      if (opt.move_perc == null) {
        opt.move_perc = 0.5;
      }
      if (opt.x == null) {
        opt.x = APP.random_x();
      }
      if (opt.y == null) {
        opt.y = APP.random_y();
      }
      return new PointWidget(opt.hue, opt.name, opt.x, opt.y, opt.move_perc);
    };

    function PointWidget() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.on_color_change = bind(this.on_color_change, this);
      this.on_move_perc_mode_change = bind(this.on_move_perc_mode_change, this);
      this.on_y_change = bind(this.on_y_change, this);
      this.on_x_change = bind(this.on_x_change, this);
      PointWidget.__super__.constructor.apply(this, args);
      APP.attach_point(this);
    }

    PointWidget.prototype.build = function() {
      var color_selector_cell, move_mode_cell, move_perc_adj_cell;
      this.draw_highlight = false;
      this.row = APP.point_pos_table.insertRow(-1);
      this.namecell = this.row.insertCell(0);
      this.set_name(this.name);
      this.color_selector_el = APP.create_input_element('color');
      this.color_selector_el.value = this.color;
      this.color_selector_el.addEventListener('change', this.on_color_change);
      color_selector_cell = this.row.insertCell(1);
      color_selector_cell.appendChild(this.color_selector_el);
      this.info_x_cell = this.row.insertCell(2);
      this.info_y_cell = this.row.insertCell(3);
      this.move_perc_cell = this.row.insertCell(4);
      this.option = {
        x: NumberUIOption.create(this.info_x_cell, this.info_x_id + "_option", this.x, this.on_x_change),
        y: NumberUIOption.create(this.info_y_cell, this.info_y_id + "_option", this.y, this.on_y_change),
        move_perc: NumberUIOption.create(this.move_perc_cell, "point_" + this.el_id + "_move_perc_option", this.move_perc * 100, this.on_move_perc_option_change)
      };
      this.move_perc_range_el = APP.create_input_element('range');
      this.move_perc_range_el_init();
      move_perc_adj_cell = this.row.insertCell(5);
      move_perc_adj_cell.appendChild(this.move_perc_range_el);
      move_mode_cell = this.row.insertCell(6);
      move_mode_cell.classList.add('move_mode');
      return this.option.move_perc_mode = BoolUIOption.create(move_mode_cell, "point_" + name + "_move_mode", this.move_perc_mode, this.on_move_perc_mode_change);
    };

    PointWidget.prototype.on_x_change = function(value) {
      this.set_x(value);
      return APP.resumable_reset();
    };

    PointWidget.prototype.on_y_change = function(value) {
      this.set_y(value);
      return APP.resumable_reset();
    };

    PointWidget.prototype.on_move_perc_mode_change = function(value) {
      this.move_perc_mode = value;
      return APP.resumable_reset();
    };

    PointWidget.prototype.update_text = function() {
      this.option.x.set(this.ix);
      return this.option.y.set(this.iy);
    };

    PointWidget.prototype.set_name = function(name) {
      this.name = name;
      return this.namecell.textContent = this.name;
    };

    PointWidget.prototype.set_color = function(color) {
      PointWidget.__super__.set_color.call(this, color);
      if (this.color_selector_el != null) {
        return this.color_selector_el.value = this.color;
      }
    };

    PointWidget.prototype.on_color_change = function(event) {
      this.set_color(event.target.value);
      return APP.resumable_reset();
    };

    PointWidget.prototype.highlight = function() {
      var oldval;
      this.row.classList.add('highlight');
      oldval = this.draw_highlight;
      this.draw_highlight = true;
      return oldval !== this.draw_highlight;
    };

    PointWidget.prototype.unhighlight = function() {
      var oldval;
      this.row.classList.remove('highlight');
      oldval = this.draw_highlight;
      this.draw_highlight = false;
      return oldval !== this.draw_highlight;
    };

    PointWidget.prototype.draw_ui = function() {
      var ctx;
      if (this.draw_highlight) {
        ctx = APP.graph_ui_ctx;
        ctx.save();
        ctx.strokeStyle = '#F97570';
        ctx.fillStyle = '#FEFFC6';
        ctx.setLineDash([4]);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.TAU, false);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
      return PointWidget.__super__.draw_ui.apply(this, arguments);
    };

    PointWidget.prototype.save = function() {
      var opt;
      return opt = {
        name: this.name,
        x: this.x,
        y: this.y,
        move_perc: this.option.move_perc.get(),
        move_mode: this.move_perc_mode ? 'percent' : 'absolute',
        color: this.color
      };
    };

    PointWidget.prototype.load = function(opt) {
      var ref;
      if (opt.name != null) {
        this.set_name(opt.name);
      }
      if ((opt.x != null) && (opt.y != null)) {
        this.move(opt.x, opt.y);
      }
      if (opt.move_perc != null) {
        if ((0.0 < (ref = opt.move_perc) && ref < 1.0)) {
          opt.move_perc *= 100;
        }
        this.set_move_perc(opt.move_perc);
      }
      if (opt.move_mode != null) {
        switch (opt.move_mode) {
          case 'percent':
            this.set_move_perc_mode(true);
            break;
          case 'absolute':
            this.set_move_perc_mode(false);
        }
      }
      if (opt.color != null) {
        this.set_color(opt.color);
      }
      return APP.resumable_reset();
    };

    PointWidget.prototype.load_default_state = function() {
      this.set_move_perc(APP.DEFAULT.move_perc * 100);
      return this.set_move_perc_mode(true);
    };

    PointWidget.prototype.destroy = function() {
      var opt, opt_name, ref;
      APP.detach_point(this);
      ref = this.option;
      for (opt_name in ref) {
        opt = ref[opt_name];
        opt.destroy();
      }
      this.color_selector_el.remove();
      this.move_perc_range_el.remove();
      return this.row.remove();
    };

    return PointWidget;

  })(UIPoint);

  DrawPoint = (function(superClass) {
    extend(DrawPoint, superClass);

    DrawPoint.prototype.prev_target = [null, null, null];

    DrawPoint.prototype.restricted = {
      single_origin: [],
      double_origin: []
    };

    function DrawPoint(name) {
      this.on_imgmask_file_change = bind(this.on_imgmask_file_change, this);
      this.on_imgmask_file_reader_load = bind(this.on_imgmask_file_reader_load, this);
      this.on_imgmask_img_load = bind(this.on_imgmask_img_load, this);
      this.on_imgmask_overlay_change = bind(this.on_imgmask_overlay_change, this);
      this.on_imgmask_offset_change = bind(this.on_imgmask_offset_change, this);
      this.on_imgmask_scale_change = bind(this.on_imgmask_scale_change, this);
      this.on_imgmask_oversample_change = bind(this.on_imgmask_oversample_change, this);
      this.on_imgmask_threshold_change = bind(this.on_imgmask_threshold_change, this);
      this.on_imgmask_enabled_change = bind(this.on_imgmask_enabled_change, this);
      this.set_draw_style = bind(this.set_draw_style, this);
      this.set_data_source = bind(this.set_data_source, this);
      this.on_set_all_points = bind(this.on_set_all_points, this);
      DrawPoint.__super__.constructor.call(this, '0', name);
      this.movement_from_origin = true;
      this.imgmask_defer_convert_img_to_bitmap = false;
      this.have_deferred_imgmask_bitmap_update = false;
      this.restrictions = new TargetRestriction(APP.context);
      this.set_color('#000000');
      this.set_draw_style(this.option.draw_style.get());
      this.set_data_source('dest');
    }

    DrawPoint.prototype.build = function() {
      var changefunc, j, len1, ref, varname;
      this.info_x_cell = APP.context.getElementById(this.info_x_id);
      this.info_y_cell = APP.context.getElementById(this.info_y_id);
      this.btn_set_all_points = APP.context.getElementById('set_all_points');
      this.move_perc_range_el = APP.context.getElementById('all_points_move_perc_range');
      this.move_perc_range_el_init();
      this.imgmask_img_hide_list = APP.context.querySelectorAll('.imgmask_img_hide');
      this.imgmask_file = APP.context.getElementById('imgmask_file');
      this.imgmask_img_caption = APP.context.getElementById('imgmask_img_caption');
      this.imgmask_img_size_width = APP.context.getElementById('imgmask_img_size_width');
      this.imgmask_img_size_height = APP.context.getElementById('imgmask_img_size_height');
      this.imgmask_bitmap_caption = APP.context.getElementById('imgmask_bitmap_caption');
      this.imgmask_bitmap_size_width = APP.context.getElementById('imgmask_bitmap_size_width');
      this.imgmask_bitmap_size_height = APP.context.getElementById('imgmask_bitmap_size_height');
      this.imgmask_img_ready = false;
      this.option = {
        imgmask_enabled: new BoolUIOption('imgmask_enabled', APP.DEFAULT.imgmask.enabled, this.on_imgmask_enabled_change),
        imgmask_threshold: new NumberUIOption('imgmask_threshold', APP.DEFAULT.imgmask.threshold, this.on_imgmask_threshold_change),
        imgmask_oversample: new NumberUIOption('imgmask_oversample', APP.DEFAULT.imgmask.oversample, this.on_imgmask_oversample_change),
        imgmask_scale_width: new NumberUIOption('imgmask_scale_width', APP.DEFAULT.imgmask.scale.width, this.on_imgmask_scale_change),
        imgmask_scale_height: new NumberUIOption('imgmask_scale_height', APP.DEFAULT.imgmask.scale.height, this.on_imgmask_scale_change),
        imgmask_offset_x: new NumberUIOption('imgmask_offset_x', APP.DEFAULT.imgmask.offset.x, this.on_imgmask_offset_change),
        imgmask_offset_y: new NumberUIOption('imgmask_offset_y', APP.DEFAULT.imgmask.offset.y, this.on_imgmask_offset_change),
        move_perc: new NumberUIOption('all_points_move_perc_option', this.move_perc * 100, this.on_move_perc_option_change),
        draw_style: new EnumUIOption('draw_style', APP.DEFAULT.cursor.draw_style, this.set_draw_style),
        data_source: new EnumUIOption('movement_data_source', APP.DEFAULT.cursor.data_source, this.set_data_source)
      };
      this.imgmask_overlay_state = {};
      changefunc = this.on_imgmask_overlay_change;
      ref = ['imgmask_scale_width', 'imgmask_scale_height', 'imgmask_offset_x', 'imgmask_offset_y'];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        varname = ref[j];
        this.imgmask_overlay_state[varname] = false;
        this.option[varname].interaction_callbacks(varname, changefunc, changefunc);
      }
      this.update_imgmask_scale();
      this.update_imgmask_offset();
      this.on_imgmask_enabled_change();
      this.imgmask_file.addEventListener('change', this.on_imgmask_file_change);
      return this.btn_set_all_points.addEventListener('click', this.on_set_all_points);
    };

    DrawPoint.prototype.save_imgmask = function() {
      var opt;
      return opt = {
        enabled: this.option.imgmask_enabled.get(),
        threshold: this.option.imgmask_threshold.get(),
        oversample: this.option.imgmask_oversample.get(),
        scale: {
          width: this.option.imgmask_scale_width.get(),
          height: this.option.imgmask_scale_height.get()
        },
        offset: {
          x: this.option.imgmask_offset_x.get(),
          y: this.option.imgmask_offset_y.get()
        }
      };
    };

    DrawPoint.prototype.load_imgmask = function(opt) {
      if (opt.enabled != null) {
        this.option.imgmask_enabled.set(opt.enabled);
      }
      if (opt.threshold != null) {
        this.option.imgmask_threshold.set(opt.threshold);
      }
      if (opt.oversample != null) {
        this.option.imgmask_oversample.set(opt.oversample);
      }
      if (opt.scale != null) {
        if ((opt.scale.width != null) && (opt.scale.height != null)) {
          this.option.imgmask_scale_width.set(opt.scale.width);
          this.option.imgmask_scale_height.set(opt.scale.height);
        }
      }
      if (opt.offset != null) {
        if ((opt.offset.x != null) && (opt.offset.y != null)) {
          this.option.imgmask_offset_x.set(opt.offset.x);
          return this.option.imgmask_offset_y.set(opt.offset.y);
        }
      }
    };

    DrawPoint.prototype.on_set_all_points = function(event) {
      APP.set_all_points_move_perc(this.move_perc * 100);
      return APP.resumable_reset();
    };

    DrawPoint.prototype.reset_color_cache = function() {
      this.color_avg = {};
      return this.prev_color_blend = Color.hexrgb_to_rgb(this.color);
    };

    DrawPoint.prototype.blend_target_colors = function(a, b) {
      var a_rgb, b_rgb, blend;
      a_rgb = Color.hexrgb_to_rgb(a.color);
      b_rgb = Color.hexrgb_to_rgb(b.color);
      blend = Color.blend_rgb(a_rgb, b_rgb);
      return "rgba(" + blend[0] + "," + blend[1] + "," + blend[2] + "," + this.alpha + ")";
    };

    DrawPoint.prototype.get_color_mono = function() {
      return this.color_alpha;
    };

    DrawPoint.prototype.get_color_target = function(target) {
      return target.color_alpha;
    };

    DrawPoint.prototype.get_color_blend_prev1 = function() {
      var a, b, base1, name;
      b = this.prev_target[1];
      a = this.prev_target[0];
      if (b == null) {
        return a.color_alpha;
      }
      name = a.name + b.name;
      return (base1 = this.color_avg)[name] != null ? base1[name] : base1[name] = this.blend_target_colors(a, b);
    };

    DrawPoint.prototype.get_color_blend_prev2 = function(target) {
      var c, p, t;
      t = Color.hexrgb_to_rgb(target.color);
      p = this.prev_color_blend;
      this.prev_color_blend = Color.blend_rgb(t, p);
      c = "rgba(" + this.prev_color_blend[0] + "," + this.prev_color_blend[1] + "," + this.prev_color_blend[2] + "," + this.alpha + ")";
      return c;
    };

    DrawPoint.prototype.set_data_source = function(src) {
      this.option.data_source.set(src);
      this.set_single_step_func();
      return APP.resumable_reset();
    };

    DrawPoint.prototype.set_single_step_func = function() {
      var ref;
      if (((ref = this.option) != null ? ref.data_source : void 0) == null) {
        return this.single = this.single_step_destinaion;
      }
      return this.single_step = (function() {
        var ref1;
        if (((ref1 = this.option) != null ? ref1.imgmask_enabled.value : void 0) && this.imgmask_img_ready) {
          switch (this.option.data_source.get()) {
            case 'dest':
              return this.single_step_destination_imgmask;
            case 'orig':
              return this.single_step_origin_imgmask;
            default:
              return this.single_step_destination_imgmask;
          }
        } else {
          switch (this.option.data_source.get()) {
            case 'dest':
              return this.single_step_destination;
            case 'orig':
              return this.single_step_origin;
            default:
              return this.single_step_destination;
          }
        }
      }).call(this);
    };

    DrawPoint.prototype.set_draw_style = function(mode) {
      this.option.draw_style.set(mode);
      return this.get_current_color = (function() {
        switch (this.option.draw_style.get()) {
          case 'mono':
            return this.get_color_mono;
          case 'color_target':
            return this.get_color_target;
          case 'color_blend_prev_target':
            return this.get_color_blend_prev1;
          case 'color_blend_prev_color':
            return this.get_color_blend_prev2;
          default:
            return this.get_color_mono;
        }
      }).call(this);
    };

    DrawPoint.prototype.set_opacity = function(opacity) {
      this.opacity = opacity;
      this.alpha = opacity / 100;
      return DrawPoint.__super__.set_opacity.call(this, opacity);
    };

    DrawPoint.prototype.on_imgmask_enabled_change = function() {
      var ref, val;
      if (((ref = this.option) != null ? ref.imgmask_enabled : void 0) != null) {
        this.set_single_step_func();
        val = this.option.imgmask_enabled.value;
        APP.imgmask_enabled = val;
        if (val) {
          return this.enable_imgmask();
        } else {
          return this.disable_imgmask();
        }
      }
    };

    DrawPoint.prototype.on_imgmask_threshold_change = function() {
      if (this.imgmask_img_ready) {
        this.imgmask_convert_img_to_bitmap();
        if (this.option.imgmask_enabled.value) {
          return APP.resumable_reset();
        }
      }
    };

    DrawPoint.prototype.on_imgmask_oversample_change = function() {
      if (this.imgmask_img_ready) {
        this.imgmask_prepare_bitmap();
        if (this.option.imgmask_enabled.value) {
          return APP.resumable_reset();
        }
      }
    };

    DrawPoint.prototype.update_imgmask_scale = function() {
      this.imgmask_scaleperc_width = this.option.imgmask_scale_width.value / 100;
      return this.imgmask_scaleperc_height = this.option.imgmask_scale_height.value / 100;
    };

    DrawPoint.prototype.update_imgmask_offset = function() {
      this.imgmask_offset_x = this.option.imgmask_offset_x.value;
      return this.imgmask_offset_y = this.option.imgmask_offset_y.value;
    };

    DrawPoint.prototype.on_imgmask_scale_change = function() {
      this.update_imgmask_scale();
      return this.update_imgmask_bitmap();
    };

    DrawPoint.prototype.on_imgmask_offset_change = function() {
      this.update_imgmask_offset();
      return this.update_imgmask_bitmap();
    };

    DrawPoint.prototype.real_update_imgmask_bitmap = function() {
      this.imgmask_convert_img_to_bitmap();
      if (this.option.imgmask_enabled.value) {
        return APP.resumable_reset();
      } else {
        if (APP.show_imgmask_overlay) {
          return APP.redraw_ui();
        }
      }
    };

    DrawPoint.prototype.run_pending_imgmask_bitmap_update = function() {
      if (this.have_deferred_imgmask_bitmap_update) {
        this.have_deferred_imgmask_bitmap_update = false;
        console.log('running previously deferred bitmap conversion');
        return this.real_update_imgmask_bitmap();
      }
    };

    DrawPoint.prototype.update_imgmask_bitmap = function() {
      if (this.imgmask_img_ready) {
        if (this.imgmask_defer_convert_img_to_bitmap) {
          console.log('deferring bitmap conversion');
          return this.have_deferred_imgmask_bitmap_update = true;
        } else {
          return this.real_update_imgmask_bitmap();
        }
      } else {
        if (APP.show_imgmask_overlay) {
          return APP.redraw_ui();
        }
      }
    };

    DrawPoint.prototype.any_imgmask_overlay_state_focused = function() {
      return Object.values(this.imgmask_overlay_state).flatten().reduce(function(x, t) {
        return x || t;
      });
    };

    DrawPoint.prototype.on_imgmask_overlay_change = function(name, has_focus) {
      this.imgmask_overlay_state[name] = has_focus;
      APP.show_imgmask_overlay = this.any_imgmask_overlay_state_focused();
      APP.prepare_imgmask_overlay();
      return APP.redraw_ui();
    };

    DrawPoint.prototype.imgmask_prepare_bitmap = function() {
      var canvas_height, canvas_width, ref;
      if (this.imgmask_bitmap != null) {
        this.imgmask_image_data = null;
        this.imgmask_bitmap.remove();
      }
      this.imgmask_bitmap = document.createElement('canvas');
      this.imgmask_oversample = this.option.imgmask_oversample.value;
      this.imgmask_bitmap.width = this.imgmask_img_width * this.imgmask_oversample;
      this.imgmask_bitmap.height = this.imgmask_img_height * this.imgmask_oversample;
      ref = APP.max_xy(), canvas_width = ref[0], canvas_height = ref[1];
      this.canvas_width_to_bitmap_width = this.imgmask_bitmap.width / canvas_width;
      this.canvas_height_to_bitmap_height = this.imgmask_bitmap.height / canvas_height;
      this.imgmask_img_size_width.textContent = '' + this.imgmask_img_width;
      this.imgmask_img_size_height.textContent = '' + this.imgmask_img_height;
      this.imgmask_bitmap_size_width.textContent = '' + this.imgmask_bitmap.width;
      this.imgmask_bitmap_size_height.textContent = '' + this.imgmask_bitmap.height;
      this.imgmask_bitmap_caption.parentElement.insertBefore(this.imgmask_bitmap, this.imgmask_bitmap_caption);
      this.imgmask_bitmap_ctx = this.imgmask_bitmap.getContext('2d', {
        alpha: false
      });
      return this.imgmask_convert_img_to_bitmap();
    };

    DrawPoint.prototype.imgmask_convert_img_to_bitmap = function() {
      var d, h, hh, hw, i, j, ref, threshold, w, x, y;
      w = this.imgmask_bitmap.width;
      h = this.imgmask_bitmap.height;
      hw = w / 2;
      hh = h / 2;
      this.imgmask_dstimg_half_width = Math.floor(hw * this.imgmask_scaleperc_width);
      this.imgmask_dstimg_half_height = Math.floor(hh * this.imgmask_scaleperc_height);
      this.imgmask_dstimg_width = 2 * this.imgmask_dstimg_half_width;
      this.imgmask_dstimg_height = 2 * this.imgmask_dstimg_half_height;
      this.imgmask_dstimg_edge_x = hw - this.imgmask_dstimg_half_width;
      this.imgmask_dstimg_edge_y = hh - this.imgmask_dstimg_half_height;
      this.imgmask_dstimg_redge_x = this.imgmask_dstimg_edge_x + this.imgmask_dstimg_width;
      this.imgmask_dstimg_redge_y = this.imgmask_dstimg_edge_y + this.imgmask_dstimg_height;
      this.imgmask_bitmap_ctx.fillStyle = 'rgb(255,255,255)';
      this.imgmask_bitmap_ctx.fillRect(0, 0, w, h);
      this.imgmask_bitmap_ctx.drawImage(this.imgmask_img, 0, 0, this.imgmask_img_width, this.imgmask_img_height, this.imgmask_dstimg_edge_x, this.imgmask_dstimg_edge_y, this.imgmask_dstimg_width, this.imgmask_dstimg_height);
      this.imgmask_image_data = this.imgmask_bitmap_ctx.getImageData(0, 0, this.imgmask_bitmap.width, this.imgmask_bitmap.height);
      d = this.imgmask_image_data.data;
      threshold = this.option.imgmask_threshold.value / 255.0;
      for (i = j = 0, ref = d.length; j < ref; i = j += 4) {
        y = Color.srgb_to_luminance(d[i], d[i + 1], d[i + 2]);
        x = y < threshold ? 0 : 255;
        d[i] = x;
        d[i + 1] = x;
        d[i + 2] = x;
      }
      return this.imgmask_bitmap_ctx.putImageData(this.imgmask_image_data, 0, 0);
    };

    DrawPoint.prototype.set_imgmask_img_ready = function(newvalue) {
      var el, j, k, len1, len2, ref, ref1, results, results1;
      this.imgmask_img_ready = newvalue;
      this.set_single_step_func();
      if (this.imgmask_img_ready) {
        ref = this.imgmask_img_hide_list;
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          el = ref[j];
          results.push(el.classList.remove('hidden'));
        }
        return results;
      } else {
        ref1 = this.imgmask_img_hide_list;
        results1 = [];
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          el = ref1[k];
          results1.push(el.classList.add('hidden'));
        }
        return results1;
      }
    };

    DrawPoint.prototype.on_imgmask_img_load = function() {
      this.imgmask_img_width = this.imgmask_img.width;
      this.imgmask_img_height = this.imgmask_img.height;
      this.imgmask_prepare_bitmap();
      return this.set_imgmask_img_ready(true);
    };

    DrawPoint.prototype.on_imgmask_file_reader_load = function(event) {
      if (this.imgmask_img != null) {
        this.imgmask_img.remove();
      }
      this.imgmask_img = new Image();
      this.imgmask_img_caption.parentElement.insertBefore(this.imgmask_img, this.imgmask_img_caption);
      this.imgmask_img.onload = this.on_imgmask_img_load;
      return this.imgmask_img.src = event.target.result;
    };

    DrawPoint.prototype.on_imgmask_file_change = function() {
      var file, reader;
      if (this.imgmask_file.files.length < 1) {
        return;
      }
      file = this.imgmask_file.files[0];
      if (!file.type.startsWith('image/')) {
        return;
      }
      this.set_imgmask_img_ready(false);
      reader = new FileReader();
      reader.onload = this.on_imgmask_file_reader_load;
      return reader.readAsDataURL(file);
    };

    DrawPoint.prototype.enable_imgmask = function() {
      this.option.imgmask_scale_width.enable();
      this.option.imgmask_scale_height.enable();
      this.option.imgmask_offset_x.enable();
      this.option.imgmask_offset_y.enable();
      this.option.imgmask_threshold.enable();
      this.option.imgmask_oversample.enable();
      return this.imgmask_file.disabled = false;
    };

    DrawPoint.prototype.disable_imgmask = function() {
      this.option.imgmask_scale_width.disable();
      this.option.imgmask_scale_height.disable();
      this.option.imgmask_offset_x.disable();
      this.option.imgmask_offset_y.disable();
      this.option.imgmask_threshold.disable();
      this.option.imgmask_oversample.disable();
      return this.imgmask_file.disabled = true;
    };

    DrawPoint.prototype.target_chosen_twice = function() {
      return this.prev_target[0] === this.prev_target[1];
    };

    DrawPoint.prototype.current_restricted_choices = function() {
      if (this.restrictions.using_double() && this.target_chosen_twice()) {
        return this.restricted.double_origin;
      } else {
        return this.restricted.single_origin;
      }
    };

    DrawPoint.prototype.filtered_choices = function(type) {
      var choices, last, len, n, neighbor, num_points, p, ref, value_getter;
      value_getter = "value_" + type;
      len = num_points = APP.points.length;
      last = len - 1;
      choices = [];
      if (!this.restrictions.option.self[value_getter]) {
        choices.push(0);
      }
      len -= 1;
      if (len % 2 === 1) {
        len -= 1;
        if (!this.restrictions.option.opposite[value_getter]) {
          choices.push(parseInt(last / 2) + 1);
        }
      }
      neighbor = 1;
      while (len >= 2) {
        ref = this.restrictions.neighbor(neighbor), p = ref[0], n = ref[1];
        if (!p[value_getter]) {
          choices.push(p.offset + num_points);
        }
        if (!n[value_getter]) {
          choices.push(n.offset);
        }
        len -= 2;
        neighbor += 1;
      }
      return choices;
    };

    DrawPoint.prototype.update_point_list_metadata = function() {
      if (APP.points.length < 3) {
        return;
      }
      this.restrictions.set_visible(APP.points.length);
      this.restricted.single_origin = this.filtered_choices('single');
      this.restricted.double_origin = this.filtered_choices('double');
      return this.prev_target[0] = this.prev_target[1] = APP.points[0];
    };

    DrawPoint.prototype.random_point = function() {
      var choice, choices, idx, prev_idx;
      choices = this.current_restricted_choices();
      choice = choices[parseInt(Math.random() * choices.length)];
      prev_idx = APP.points.indexOf(this.prev_target[0]);
      idx = (choice + prev_idx) % APP.points.length;
      return APP.points[idx];
    };

    DrawPoint.prototype.draw_graph = function(target) {
      var ctx;
      this.prev_target[2] = this.prev_target[1];
      this.prev_target[1] = this.prev_target[0];
      this.prev_target[0] = target;
      ctx = APP.graph_ctx;
      ctx.fillStyle = this.get_current_color(target);
      ctx.fillRect(this.x, this.y, 1, 1);
      return null;
    };

    DrawPoint.prototype.single_step_origin = function() {
      var origin, target;
      target = this.random_point();
      if (target == null) {
        return false;
      }
      origin = this.prev_target[0];
      if (origin.move_perc_mode) {
        this.move_perc_towards_no_text_update(target, origin.move_perc);
      } else {
        this.move_absolute_towards_no_text_update(target, origin.move_perc);
      }
      this.draw_graph(target);
      return true;
    };

    DrawPoint.prototype.single_step_destination = function() {
      var target;
      target = this.random_point();
      if (target == null) {
        return false;
      }
      if (target.move_perc_mode) {
        this.move_perc_towards_no_text_update(target, target.move_perc);
      } else {
        this.move_absolute_towards_no_text_update(target, target.move_perc);
      }
      this.draw_graph(target);
      return true;
    };

    DrawPoint.prototype.single_step_origin_imgmask = function() {
      var choice, coords, idx, j, len1, origin, prev_idx, ref, target, tries;
      origin = this.prev_target[0];
      tries = [];
      ref = this.current_restricted_choices().shuffle();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        choice = ref[j];
        prev_idx = APP.points.indexOf(origin);
        idx = (choice + prev_idx) % APP.points.length;
        target = APP.points[idx];
        coords = origin.move_perc_mode ? this.coords_after_move_perc_towards_target(target, origin.move_perc) : this.coords_after_move_absolute_towards_target(target, origin.move_perc);
        if (this.collides_with_bitmap.apply(this, coords)) {
          tries.push({
            target: target,
            coords: coords
          });
          continue;
        }
        this.move_no_text_update_array(coords);
        this.draw_graph(target);
        return true;
      }
      this.log_all_targets_collide(tries);
      return false;
    };

    DrawPoint.prototype.single_step_destination_imgmask = function() {
      var choice, coords, idx, j, len1, prev_idx, ref, target, tries;
      tries = [];
      ref = this.current_restricted_choices().shuffle();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        choice = ref[j];
        prev_idx = APP.points.indexOf(this.prev_target[0]);
        idx = (choice + prev_idx) % APP.points.length;
        target = APP.points[idx];
        coords = target.move_perc_mode ? this.coords_after_move_perc_towards_target(target, target.move_perc) : this.coords_after_move_absolute_towards_target(target, target.move_perc);
        if (this.collides_with_bitmap.apply(this, coords)) {
          tries.push({
            target: target,
            coords: coords
          });
          continue;
        }
        this.move_no_text_update_array(coords);
        this.draw_graph(target);
        return true;
      }
      this.log_all_targets_collide(tries);
      return false;
    };

    DrawPoint.prototype.log_all_targets_collide = function(tries) {
      var G, coords, idx, j, len1, results, t;
      APP.redraw_ui();
      console.log('All moves collide with the bitmap');
      console.log('Current location xy', this.x, this.y);
      results = [];
      for (idx = j = 0, len1 = tries.length; j < len1; idx = ++j) {
        t = tries[idx];
        target(G = t.target);
        coords = t.coords;
        results.push(console.log(" * Try #" + idx + ": target '" + target.name + "' at xy", target.x, target.y, 'coords xy', coords[0], coords[1]));
      }
      return results;
    };

    DrawPoint.prototype.collides_with_bitmap = function(x, y) {
      var offset, testx, testy;
      testx = Math.floor(x * this.canvas_width_to_bitmap_width);
      testy = Math.floor(y * this.canvas_height_to_bitmap_height);
      offset = ((testy * this.imgmask_bitmap.width) + testx) * 4;
      return this.imgmask_image_data.data[offset] < 128;
    };

    return DrawPoint;

  })(UIPoint);

  DNDHandler = (function() {
    function DNDHandler(optname, defer_bitmap_updates) {
      this.optname = optname;
      this.defer_bitmap_updates = defer_bitmap_updates != null ? defer_bitmap_updates : true;
      this.option = APP.cur.option[this.optname];
      this.oldvalue = this.option.get();
      this.newvalue = this.oldvalue;
      if (this.defer_bitmap_updates) {
        APP.cur.imgmask_defer_convert_img_to_bitmap = true;
      }
    }

    DNDHandler.prototype.move = function(x, y) {
      this.newvalue = this.loc_to_value(x, y);
      return this.option.set(this.newvalue);
    };

    DNDHandler.prototype.commit = function() {
      if (this.defer_bitmap_updates) {
        APP.cur.imgmask_defer_convert_img_to_bitmap = false;
        APP.cur.run_pending_imgmask_bitmap_update();
      }
      if (this.newvalue !== this.oldvalue) {
        if (this.on_change != null) {
          return this.on_change();
        }
      }
    };

    return DNDHandler;

  })();

  OffsetDNDHandler = (function(superClass) {
    extend(OffsetDNDHandler, superClass);

    function OffsetDNDHandler() {
      return OffsetDNDHandler.__super__.constructor.apply(this, arguments);
    }

    OffsetDNDHandler.prototype.on_change = function() {
      return APP != null ? APP.cur.on_imgmask_offset_change() : void 0;
    };

    return OffsetDNDHandler;

  })(DNDHandler);

  XOffsetDNDHandler = (function(superClass) {
    extend(XOffsetDNDHandler, superClass);

    function XOffsetDNDHandler() {
      return XOffsetDNDHandler.__super__.constructor.apply(this, arguments);
    }

    XOffsetDNDHandler.prototype.loc_to_value = function(x, y) {
      var newvalue;
      newvalue = x - APP.image_edge_x;
      return newvalue;
    };

    return XOffsetDNDHandler;

  })(OffsetDNDHandler);

  YOffsetDNDHandler = (function(superClass) {
    extend(YOffsetDNDHandler, superClass);

    function YOffsetDNDHandler() {
      return YOffsetDNDHandler.__super__.constructor.apply(this, arguments);
    }

    YOffsetDNDHandler.prototype.loc_to_value = function(x, y) {
      var newvalue;
      newvalue = y - APP.image_edge_y;
      return newvalue;
    };

    return YOffsetDNDHandler;

  })(OffsetDNDHandler);

  ScaleDNDHandler = (function(superClass) {
    extend(ScaleDNDHandler, superClass);

    function ScaleDNDHandler() {
      return ScaleDNDHandler.__super__.constructor.apply(this, arguments);
    }

    ScaleDNDHandler.prototype.on_change = function() {
      return APP != null ? APP.cur.on_imgmask_scale_change() : void 0;
    };

    return ScaleDNDHandler;

  })(DNDHandler);

  ScaleWidthDNDHandler = (function(superClass) {
    extend(ScaleWidthDNDHandler, superClass);

    function ScaleWidthDNDHandler() {
      return ScaleWidthDNDHandler.__super__.constructor.apply(this, arguments);
    }

    ScaleWidthDNDHandler.prototype.loc_to_value = function(x, y) {};

    return ScaleWidthDNDHandler;

  })(ScaleDNDHandler);

  ScaleHeightDNDHandler = (function(superClass) {
    extend(ScaleHeightDNDHandler, superClass);

    function ScaleHeightDNDHandler() {
      return ScaleHeightDNDHandler.__super__.constructor.apply(this, arguments);
    }

    ScaleHeightDNDHandler.prototype.loc_to_value = function(x, y) {};

    return ScaleHeightDNDHandler;

  })(ScaleDNDHandler);

  MultiDNDHandler = (function() {
    function MultiDNDHandler() {
      var handlers;
      handlers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.handlers = handlers;
    }

    MultiDNDHandler.prototype.move = function(x, y) {
      var h, j, len1, ref, results;
      APP.cur.imgmask_defer_convert_img_to_bitmap = true;
      ref = this.handlers;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        h = ref[j];
        results.push(h.move(x, y));
      }
      return results;
    };

    MultiDNDHandler.prototype.commit = function() {
      var h, j, len1, ref, results;
      APP.cur.imgmask_defer_convert_img_to_bitmap = false;
      APP.cur.run_pending_imgmask_bitmap_update();
      ref = this.handlers;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        h = ref[j];
        results.push(h.commit());
      }
      return results;
    };

    return MultiDNDHandler;

  })();

  TargetRestrictionOption = (function() {
    function TargetRestrictionOption(context, offset1, name1) {
      var double_selector, selector, single_selector;
      this.context = context;
      this.offset = offset1;
      this.name = name1;
      this.on_change_double = bind(this.on_change_double, this);
      this.on_change_single = bind(this.on_change_single, this);
      selector = "#restrict_table ." + this.name;
      this.column_cells = this.context.querySelectorAll(selector);
      single_selector = selector + ".single input[type=\"checkbox\"]";
      double_selector = selector + ".double input[type=\"checkbox\"]";
      this.checkbox_single = this.context.querySelector(single_selector);
      this.checkbox_double = this.context.querySelector(double_selector);
      this.replace_with_styled_label(this.checkbox_single);
      this.replace_with_styled_label(this.checkbox_double);
      this.callbacks_single = [];
      this.callbacks_double = [];
      this.visible = false;
      this.reset();
      this.checkbox_single.addEventListener('change', this.on_change_single);
      this.checkbox_double.addEventListener('change', this.on_change_double);
    }

    TargetRestrictionOption.prototype.replace_with_styled_label = function(checkbox) {
      var cell, container, mark_active, mark_inactive;
      cell = checkbox.parentElement;
      container = this.context.createElement('label');
      mark_inactive = this.context.createElement('span');
      mark_active = this.context.createElement('span');
      mark_active.textContent = '\u2613';
      container.setAttribute('for', checkbox.id);
      container.classList.add('styled_checkbox_container');
      checkbox.classList.add('hidden_checkbox');
      mark_inactive.classList.add('checkmark');
      mark_inactive.classList.add('inactive');
      mark_active.classList.add('checkmark');
      mark_active.classList.add('active');
      container.appendChild(checkbox);
      container.appendChild(mark_inactive);
      container.appendChild(mark_active);
      return cell.appendChild(container);
    };

    TargetRestrictionOption.prototype.add_callback_on_changes_single = function(callback) {
      return this.callbacks_single.push(callback);
    };

    TargetRestrictionOption.prototype.add_callback_on_changes_double = function(callback) {
      return this.callbacks_double.push(callback);
    };

    TargetRestrictionOption.prototype.reset = function() {
      this.set_single(false);
      return this.set_double(false);
    };

    TargetRestrictionOption.prototype.set_column_cells = function(state) {
      var cell, j, len1, ref, results;
      ref = this.column_cells;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        cell = ref[j];
        results.push(cell.style.display = state);
      }
      return results;
    };

    TargetRestrictionOption.prototype.show = function() {
      this.visible = true;
      return this.set_column_cells('table-cell');
    };

    TargetRestrictionOption.prototype.hide = function() {
      this.visible = false;
      return this.set_column_cells('none');
    };

    TargetRestrictionOption.prototype.enable_single = function() {
      return this.checkbox_single.disabled = false;
    };

    TargetRestrictionOption.prototype.enable_double = function() {
      return this.checkbox_double.disabled = false;
    };

    TargetRestrictionOption.prototype.disable_single = function() {
      return this.checkbox_single.disabled = true;
    };

    TargetRestrictionOption.prototype.disable_double = function() {
      return this.checkbox_double.disabled = true;
    };

    TargetRestrictionOption.prototype.is_single_enabled = function() {
      return !this.checkbox_double.disabled;
    };

    TargetRestrictionOption.prototype.is_double_enabled = function() {
      return !this.checkbox_double.disabled;
    };

    TargetRestrictionOption.prototype.using_double = function() {
      return this.visible && this.is_double_enabled() && this.value_double;
    };

    TargetRestrictionOption.prototype.set_single = function(value) {
      var cb, j, len1, ref;
      if (value !== this.value_single) {
        this.value_single = value;
        this.checkbox_single.checked = this.value_single;
        ref = this.callbacks_single;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          cb = ref[j];
          cb(value);
        }
        return APP.update_metadata_and_reset();
      }
    };

    TargetRestrictionOption.prototype.set_double = function(value) {
      var cb, j, len1, ref;
      if (value !== this.value_double) {
        this.value_double = value;
        this.checkbox_double.checked = this.value_double;
        ref = this.callbacks_double;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          cb = ref[j];
          cb(value);
        }
        return APP.update_metadata_and_reset();
      }
    };

    TargetRestrictionOption.prototype.on_change_single = function(event) {
      return this.set_single(event.target.checked);
    };

    TargetRestrictionOption.prototype.on_change_double = function(event) {
      return this.set_double(event.target.checked);
    };

    return TargetRestrictionOption;

  })();

  TargetRestriction = (function() {
    function TargetRestriction(context) {
      var j, len1, o, ref;
      this.context = context;
      this.on_self_singe_change = bind(this.on_self_singe_change, this);
      this.option = {
        prev: [new TargetRestrictionOption(this.context, -1, 'prev1'), new TargetRestrictionOption(this.context, -2, 'prev2'), new TargetRestrictionOption(this.context, -3, 'prev3')],
        self: new TargetRestrictionOption(this.context, 0, 'self'),
        next: [new TargetRestrictionOption(this.context, 1, 'next1'), new TargetRestrictionOption(this.context, 2, 'next2'), new TargetRestrictionOption(this.context, 3, 'next3')],
        opposite: new TargetRestrictionOption(this.context, 4, 'opposite')
      };
      this.options = Object.values(this.option).flatten();
      this.by_name = {};
      ref = this.options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        this.by_name[o.name] = o;
      }
      this.option.self.add_callback_on_changes_single(this.on_self_singe_change);
    }

    TargetRestriction.prototype.on_self_singe_change = function(is_restricted) {
      if (is_restricted) {
        return this.disable_double();
      } else {
        return this.enable_double();
      }
    };

    TargetRestriction.prototype.enable_double = function() {
      var j, len1, o, ref, results;
      ref = this.options;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        results.push(o.enable_double());
      }
      return results;
    };

    TargetRestriction.prototype.disable_double = function() {
      var j, len1, o, ref, results;
      ref = this.options;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        results.push(o.disable_double());
      }
      return results;
    };

    TargetRestriction.prototype.find = function(name) {
      if (this.by_name[name] != null) {
        return this.by_name[name];
      } else {
        console.log("no such restriction named '" + name + "'");
        return null;
      }
    };

    TargetRestriction.prototype.set_visible = function(n) {
      var j, len1, neighbor, next, o, prev, ref, ref1;
      ref = this.options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        o.hide();
      }
      this.option.self.show();
      n -= 1;
      if (n % 2 === 1) {
        this.option.opposite.show();
        n -= 1;
      }
      neighbor = 1;
      while (n >= 2) {
        ref1 = this.neighbor(neighbor), prev = ref1[0], next = ref1[1];
        prev.show();
        next.show();
        n -= 2;
        neighbor += 1;
      }
      return null;
    };

    TargetRestriction.prototype.using_double = function() {
      var j, len1, o, ref;
      ref = this.options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        if (o.using_double()) {
          return true;
        }
      }
      return false;
    };

    TargetRestriction.prototype.restricted_single = function() {
      return this.options.filter(function(o) {
        return o.value_single;
      });
    };

    TargetRestriction.prototype.restricted_double = function() {
      return this.options.filter(function(o) {
        return o.value_double;
      });
    };

    TargetRestriction.prototype.neighbor = function(n) {
      return [this.by_name["prev" + n], this.by_name["next" + n]];
    };

    TargetRestriction.prototype.save = function() {
      var opt;
      return opt = {
        single: this.restricted_single().map(function(x) {
          return x.name;
        }),
        double: this.restricted_double().map(function(x) {
          return x.name;
        })
      };
    };

    TargetRestriction.prototype.load = function(opt) {
      var j, k, len1, len2, len3, m, name, o, ref, ref1, ref2, ref3;
      for (j = 0, len1 = opt.length; j < len1; j++) {
        o = opt[j];
        o.reset();
      }
      if (opt.single != null) {
        ref = opt.single;
        for (k = 0, len2 = ref.length; k < len2; k++) {
          name = ref[k];
          if ((ref1 = this.find(name)) != null) {
            ref1.set_single(true);
          }
        }
      }
      if (opt.double != null) {
        ref2 = opt.double;
        for (m = 0, len3 = ref2.length; m < len3; m++) {
          name = ref2[m];
          if ((ref3 = this.find(name)) != null) {
            ref3.set_double(true);
          }
        }
      }
      return APP.update_metadata_and_reset();
    };

    TargetRestriction.prototype.load_default_state = function() {
      var j, len1, o, ref, results;
      ref = this.options;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        o = ref[j];
        results.push(o.reset());
      }
      return results;
    };

    return TargetRestriction;

  })();

  UIOption = (function() {
    function UIOption(id1, _default, on_change_callback) {
      this.id = id1;
      this["default"] = _default;
      this.on_change_callback = on_change_callback;
      this.on_mouseleave = bind(this.on_mouseleave, this);
      this.on_mouseenter = bind(this.on_mouseenter, this);
      this.on_blur = bind(this.on_blur, this);
      this.on_focus = bind(this.on_focus, this);
      this.on_change = bind(this.on_change, this);
      if (this.id instanceof Element) {
        this.el = this.id;
        this.id = this.el.id;
      } else {
        this.el = APP.context.getElementById(this.id);
      }
      this.set(this["default"]);
      this.el.addEventListener('change', this.on_change);
    }

    UIOption.prototype.on_change = function(event) {
      this.set(this.get(event.target));
      if (this.on_change_callback != null) {
        return this.on_change_callback(this.value);
      }
    };

    UIOption.prototype.enable = function() {
      return this.el.disabled = false;
    };

    UIOption.prototype.disable = function() {
      return this.el.disabled = true;
    };

    UIOption.prototype.interaction_callbacks = function(interaction_name, focus_callback, blur_callback) {
      this.interaction_name = interaction_name;
      this.focus_callback = focus_callback;
      this.blur_callback = blur_callback;
      if (this.interaction_events_captured == null) {
        this.el.addEventListener('focus', this.on_focus);
        this.el.addEventListener('blur', this.on_blur);
        this.el.addEventListener('mouseenter', this.on_mouseenter);
        this.el.addEventListener('mouseleave', this.on_mouseleave);
        this.interaction_events_captured = true;
        this.have_focus = false;
        return this.have_mouse = false;
      }
    };

    UIOption.prototype.on_focus = function() {
      this.have_focus = true;
      if (this.focus_callback != null) {
        if (!this.have_mouse) {
          return this.focus_callback(this.interaction_name, true);
        }
      }
    };

    UIOption.prototype.on_blur = function() {
      this.have_focus = false;
      if (this.blur_callback != null) {
        if (!this.have_mouse) {
          return this.blur_callback(this.interaction_name, false);
        }
      }
    };

    UIOption.prototype.on_mouseenter = function() {
      this.have_mouse = true;
      if (this.focus_callback != null) {
        if (!this.have_focus) {
          return this.focus_callback(this.interaction_name, true);
        }
      }
    };

    UIOption.prototype.on_mouseleave = function() {
      this.have_mouse = false;
      if (this.blur_callback != null) {
        if (!this.have_focus) {
          return this.blur_callback(this.interaction_name, false);
        }
      }
    };

    UIOption.prototype.destroy = function() {
      if (this.el != null) {
        this.el.remove();
      }
      return this.el = null;
    };

    return UIOption;

  })();

  BoolUIOption = (function(superClass) {
    extend(BoolUIOption, superClass);

    function BoolUIOption() {
      return BoolUIOption.__super__.constructor.apply(this, arguments);
    }

    BoolUIOption.create = function() {
      var id1, opt, parent, rest;
      parent = arguments[0], id1 = arguments[1], rest = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.id = id1;
      opt = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(BoolUIOption, [APP.create_input_element('checkbox', this.id)].concat(slice.call(rest)), function(){});
      parent.appendChild(opt.el);
      return opt;
    };

    BoolUIOption.prototype.get = function(element) {
      if (element == null) {
        element = this.el;
      }
      return element.checked;
    };

    BoolUIOption.prototype.set = function(bool_value) {
      this.value = (function() {
        switch (bool_value) {
          case 'true':
            return true;
          case 'false':
            return false;
          default:
            return !!bool_value;
        }
      })();
      return this.el.checked = this.value;
    };

    return BoolUIOption;

  })(UIOption);

  NumberUIOption = (function(superClass) {
    extend(NumberUIOption, superClass);

    function NumberUIOption() {
      return NumberUIOption.__super__.constructor.apply(this, arguments);
    }

    NumberUIOption.create = function() {
      var id1, opt, parent, rest;
      parent = arguments[0], id1 = arguments[1], rest = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.id = id1;
      opt = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(NumberUIOption, [APP.create_input_element('number', this.id)].concat(slice.call(rest)), function(){});
      parent.appendChild(opt.el);
      return opt;
    };

    NumberUIOption.prototype.get = function(element) {
      if (element == null) {
        element = this.el;
      }
      return parseInt(element.value);
    };

    NumberUIOption.prototype.set = function(number_value) {
      this.value = parseInt(number_value);
      return this.el.value = this.value;
    };

    NumberUIOption.prototype.set_range = function(min, max, step) {
      if (step == null) {
        step = 1;
      }
      this.el.min = min;
      this.el.max = max;
      return this.el.step = step;
    };

    return NumberUIOption;

  })(UIOption);

  EnumUIOption = (function(superClass) {
    extend(EnumUIOption, superClass);

    function EnumUIOption() {
      return EnumUIOption.__super__.constructor.apply(this, arguments);
    }

    EnumUIOption.prototype.get = function(element) {
      if (element == null) {
        element = this.el;
      }
      return element.value;
    };

    EnumUIOption.prototype.find_option_by_value = function(enum_value) {
      var j, len1, opt, ref;
      ref = this.el.options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        opt = ref[j];
        if (opt.value === enum_value) {
          return opt;
        }
      }
      return null;
    };

    EnumUIOption.prototype.set = function(enum_value) {
      var opt;
      opt = this.find_option_by_value(enum_value);
      if (opt != null) {
        this.el.value = opt.value;
      }
      return this.value = this.el.value;
    };

    return EnumUIOption;

  })(UIOption);

  StochasticSierpinski = (function() {
    StochasticSierpinski.prototype.MIN_POINTS = 3;

    StochasticSierpinski.prototype.MAX_POINTS = 8;

    StochasticSierpinski.prototype.REG_POLYGON_MARGIN = 10;

    StochasticSierpinski.prototype.NEARBY_RADIUS = 8;

    StochasticSierpinski.prototype.DEFAULT = {
      show_tooltips: true,
      graph: {
        width: 420,
        height: 420
      },
      draw_opacity: 35,
      move_range_min: 0,
      move_range_max: 100,
      move_perc: 0.5,
      cursor: {
        draw_style: 'color_blend_prev_color',
        data_source: 'dest'
      },
      imgmask: {
        enabled: false,
        scale: {
          width: 50,
          height: 50
        },
        offset: {
          x: 0,
          y: 0
        },
        threshold: 1,
        oversample: 1
      }
    };

    StochasticSierpinski.prototype.points = [];

    StochasticSierpinski.prototype.move_absolute_magnitude = 100;

    function StochasticSierpinski(context) {
      this.context = context;
      this.load_from_cookie = bind(this.load_from_cookie, this);
      this.on_hashchange = bind(this.on_hashchange, this);
      this.on_keydown = bind(this.on_keydown, this);
      this.update = bind(this.update, this);
      this.redraw_ui = bind(this.redraw_ui, this);
      this.prepare_imgmask_overlay = bind(this.prepare_imgmask_overlay, this);
      this.step = bind(this.step, this);
      this.stop = bind(this.stop, this);
      this.start = bind(this.start, this);
      this.on_run = bind(this.on_run, this);
      this.on_multistep = bind(this.on_multistep, this);
      this.on_step = bind(this.on_step, this);
      this.on_reset = bind(this.on_reset, this);
      this.resumable_reset = bind(this.resumable_reset, this);
      this.on_mousemove = bind(this.on_mousemove, this);
      this.on_mouseup = bind(this.on_mouseup, this);
      this.on_mousedown = bind(this.on_mousedown, this);
      this.max_xy = bind(this.max_xy, this);
      this.random_y = bind(this.random_y, this);
      this.random_x = bind(this.random_x, this);
      this.on_move_all_random = bind(this.on_move_all_random, this);
      this.on_move_all_reg_polygon = bind(this.on_move_all_reg_polygon, this);
      this.on_save_url = bind(this.on_save_url, this);
      this.on_load = bind(this.on_load, this);
      this.on_save = bind(this.on_save, this);
      this.deserialize = bind(this.deserialize, this);
      this.on_serializebox_cancel = bind(this.on_serializebox_cancel, this);
      this.on_serializebox_action = bind(this.on_serializebox_action, this);
      this.on_create_png = bind(this.on_create_png, this);
      this.on_steps_per_frame_input = bind(this.on_steps_per_frame_input, this);
      this.on_num_points_input = bind(this.on_num_points_input, this);
      this.on_canvas_height_change = bind(this.on_canvas_height_change, this);
      this.on_canvas_width_change = bind(this.on_canvas_width_change, this);
      this.on_graph_wrapper_mutate = bind(this.on_graph_wrapper_mutate, this);
      this.on_mouseleave = bind(this.on_mouseleave, this);
      this.on_mouseenter = bind(this.on_mouseenter, this);
      this.on_draw_opacity_change = bind(this.on_draw_opacity_change, this);
      this.on_move_range_change = bind(this.on_move_range_change, this);
      this.on_show_tooltips_change = bind(this.on_show_tooltips_change, this);
    }

    StochasticSierpinski.prototype.init = function() {
      var i, j, k, r, ref, ref1, s;
      this.running = false;
      this.enable_imgmask_dnd = false;
      this.mouse_over_graph = false;
      this.show_imgmask_overlay = false;
      this.imgmask_enabled = false;
      this.imgmask_overlay_highlight = null;
      this.step_count = 0;
      this.steps_per_frame_el = this.context.getElementById('steps_per_frame');
      this.content_el = this.context.getElementById('content');
      this.graph_wrapper = this.context.getElementById('graph_wrapper');
      this.graph_canvas = this.context.getElementById('graph');
      this.graph_ui_canvas = this.context.getElementById('graph_ui');
      this.graph_ctx = this.graph_canvas.getContext('2d', {
        alpha: true
      });
      this.graph_ui_ctx = this.graph_ui_canvas.getContext('2d', {
        alpha: true
      });
      this.btn_reset = this.context.getElementById('button_reset');
      this.btn_step = this.context.getElementById('button_step');
      this.btn_multistep = this.context.getElementById('button_multistep');
      this.btn_run = this.context.getElementById('button_run');
      this.btn_create_png = this.context.getElementById('button_create_png');
      this.btn_save_url = this.context.getElementById('button_save_url');
      this.btn_save = this.context.getElementById('button_save');
      this.btn_load = this.context.getElementById('button_load');
      this.total_steps_cell = this.context.getElementById('total_steps');
      this.point_pos_table = this.context.getElementById('point_pos_table');
      this.num_points_el = this.context.getElementById('num_points');
      this.btn_move_all_reg_polygon = this.context.getElementById('move_all_reg_polygon');
      this.btn_move_all_random = this.context.getElementById('move_all_random');
      this.option = {
        show_tooltips: new BoolUIOption('show_tooltips', APP.DEFAULT.show_tooltips, this.on_show_tooltips_change),
        canvas_width: new NumberUIOption('canvas_width', APP.DEFAULT.graph.width, this.on_canvas_width_change),
        canvas_height: new NumberUIOption('canvas_height', APP.DEFAULT.graph.height, this.on_canvas_height_change),
        draw_opacity: new NumberUIOption('draw_opacity', APP.DEFAULT.draw_opacity, this.on_draw_opacity_change),
        move_range_min: new NumberUIOption('move_range_min', APP.DEFAULT.move_range_min, this.on_move_range_change),
        move_range_max: new NumberUIOption('move_range_max', APP.DEFAULT.move_range_max, this.on_move_range_change)
      };
      this.serializebox = this.context.getElementById('serializebox');
      this.serializebox_title = this.context.getElementById('serializebox_title');
      this.serializebox_text = this.context.getElementById('serializebox_text');
      this.serializebox_action = this.context.getElementById('serializebox_action');
      this.serializebox_cancel = this.context.getElementById('serializebox_cancel');
      this.graph_wrapper.addEventListener('mouseenter', this.on_mouseenter);
      this.graph_wrapper.addEventListener('mouseleave', this.on_mouseleave);
      for (i = j = 0, ref = document.styleSheets.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        s = document.styleSheets[i];
        if ((s != null ? s.title : void 0) === 'app_stylesheet') {
          this.app_stylesheet = s;
          break;
        }
      }
      if (this.app_stylesheet != null) {
        for (i = k = 0, ref1 = this.app_stylesheet.cssRules.length; 0 <= ref1 ? k <= ref1 : k >= ref1; i = 0 <= ref1 ? ++k : --k) {
          r = this.app_stylesheet.cssRules[i];
          if ((r != null ? r.selectorText : void 0) === '.canvas_size') {
            this.canvas_size_rule = r;
            break;
          }
        }
        if (this.canvas_size_rule != null) {
          this.graph_wrapper_observer = new MutationObserver(this.on_graph_wrapper_mutate);
          this.graph_wrapper_observer.observe(this.graph_wrapper, {
            attributes: true
          });
        }
      }
      this.resize_graph(this.option.canvas_width.get(), this.option.canvas_height.get());
      this.cur = new DrawPoint('Cur');
      this.load_default_state();
      this.set_steps_per_frame(100, false);
      this.num_points_el.addEventListener('input', this.on_num_points_input);
      this.steps_per_frame_el.addEventListener('input', this.on_steps_per_frame_input);
      this.btn_reset.addEventListener('click', this.on_reset);
      this.btn_step.addEventListener('click', this.on_step);
      this.btn_multistep.addEventListener('click', this.on_multistep);
      this.btn_run.addEventListener('click', this.on_run);
      this.context.addEventListener('keydown', this.on_keydown);
      this.btn_create_png.addEventListener('click', this.on_create_png);
      this.btn_save_url.addEventListener('click', this.on_save_url);
      this.btn_save.addEventListener('click', this.on_save);
      this.btn_load.addEventListener('click', this.on_load);
      this.btn_move_all_reg_polygon.addEventListener('click', this.on_move_all_reg_polygon);
      this.btn_move_all_random.addEventListener('click', this.on_move_all_random);
      this.serializebox_action.addEventListener('click', this.on_serializebox_action);
      this.serializebox_cancel.addEventListener('click', this.on_serializebox_cancel);
      this.graph_ui_canvas.addEventListener('mousedown', this.on_mousedown);
      this.graph_ui_canvas.addEventListener('mouseup', this.on_mouseup);
      this.graph_ui_canvas.addEventListener('mousemove', this.on_mousemove);
      window.addEventListener('hashchange', this.on_hashchange);
      return this.clear_update_and_draw();
    };

    StochasticSierpinski.prototype.debug = function(msg) {
      var timestamp;
      if (this.debugbox == null) {
        this.debugbox = this.context.getElementById('debugbox');
        this.debugbox_hdr = this.debugbox.querySelector('.hdr');
        this.debugbox_msg = this.debugbox.querySelector('.msg');
        this.debugbox.classList.remove('hidden');
      }
      timestamp = new Date();
      this.debugbox_hdr.textContent = timestamp.toISOString();
      return this.debugbox_msg.textContent = '' + msg;
    };

    StochasticSierpinski.prototype.load_default_state = function() {
      var j, k, len1, len2, p, r, ref, ref1, results;
      this.set_ngon(3);
      this.option.canvas_width.set(APP.DEFAULT.graph.width);
      this.option.canvas_height.set(APP.DEFAULT.graph.height);
      this.option.draw_opacity.set(APP.DEFAULT.draw_opacity);
      this.option.move_range_min.set(APP.DEFAULT.move_range_min);
      this.option.move_range_max.set(APP.DEFAULT.move_range_max);
      this.set_move_range();
      this.cur.set_move_perc(APP.DEFAULT.move_perc * 100);
      this.cur.set_draw_style(APP.DEFAULT.cursor.draw_style);
      this.cur.set_data_source(APP.DEFAULT.cursor.data_source);
      ref = this.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        p.load_default_state();
      }
      ref1 = this.cur.restrictions;
      results = [];
      for (k = 0, len2 = ref1.length; k < len2; k++) {
        r = ref1[k];
        results.push(r.load_default_state());
      }
      return results;
    };

    StochasticSierpinski.prototype.create_element = function(name, id) {
      var el;
      if (id == null) {
        id = null;
      }
      el = this.context.createElement(name);
      if (id != null) {
        el.id = id;
      }
      return el;
    };

    StochasticSierpinski.prototype.create_input_element = function(type, id) {
      var el;
      if (id == null) {
        id = null;
      }
      el = this.create_element('input', id);
      el.type = type;
      return el;
    };

    StochasticSierpinski.prototype.on_show_tooltips_change = function(value) {
      if (value) {
        this.content_el.classList.add('show_tt');
      } else {
        this.content_el.classList.remove('show_tt');
      }
      return this.serialize_cookie('show_tooltips', value);
    };

    StochasticSierpinski.prototype.on_move_range_change = function() {
      this.set_move_range(this.option.move_range_min.get(), this.option.move_range_max.get());
      return this.resumable_reset();
    };

    StochasticSierpinski.prototype.set_move_range = function(min, max) {
      var j, len1, p, ref, results;
      if (min == null) {
        min = APP.DEFAULT.move_range_min;
      }
      if (max == null) {
        max = APP.DEFAULT.move_range_max;
      }
      this.cur.set_move_range(min, max);
      ref = this.points;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        results.push(p.set_move_range(min, max));
      }
      return results;
    };

    StochasticSierpinski.prototype.on_draw_opacity_change = function() {
      var j, len1, o, p, ref, results;
      o = this.option.draw_opacity.value;
      this.cur.set_opacity(o);
      ref = this.points;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        results.push(p.set_opacity(o));
      }
      return results;
    };

    StochasticSierpinski.prototype.clear_update_and_draw = function() {
      this.update_info_elements();
      this.clear_graph_canvas();
      return this.redraw_ui();
    };

    StochasticSierpinski.prototype.on_mouseenter = function() {
      this.graph_wrapper.classList.add('resizable');
      this.mouse_over_graph = true;
      return this.redraw_ui();
    };

    StochasticSierpinski.prototype.on_mouseleave = function() {
      this.graph_wrapper.classList.remove('resizable');
      this.mouse_over_graph = false;
      return this.redraw_ui();
    };

    StochasticSierpinski.prototype.on_graph_wrapper_mutate = function(event) {
      if (this.graph_wrapper.offsetWidth !== this.graph_ui_canvas.width || this.graph_wrapper.offsetHeight !== this.graph_ui_canvas.height) {
        this.resize_graph(this.graph_wrapper.offsetWidth, this.graph_wrapper.offsetHeight);
        return APP.resumable_reset();
      }
    };

    StochasticSierpinski.prototype.clamp_points_to_canvas = function() {
      var height, j, len1, p, ref, ref1, results, width;
      ref = APP.max_xy(), width = ref[0], height = ref[1];
      ref1 = APP.points;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        p = ref1[j];
        if (p.x < 0) {
          p.x = 0;
        }
        if (p.y < 0) {
          p.y = 0;
        }
        if (p.x >= width) {
          p.x = width - 1;
        }
        if (p.y >= height) {
          results.push(p.y = height - 1);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    StochasticSierpinski.prototype.resize_graph_width = function(w) {
      var j, len1, p, ref, scale, style_width;
      scale = w / this.graph_canvas.width;
      ref = this.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        p.scale_width(scale);
      }
      style_width = w + "px";
      this.graph_canvas.width = w;
      this.graph_ui_canvas.width = w;
      this.graph_wrapper.style.width = style_width;
      this.canvas_size_rule.style.width = style_width;
      this.option.canvas_width.set(w);
      return APP.prepare_imgmask_overlay();
    };

    StochasticSierpinski.prototype.resize_graph_height = function(h) {
      var j, len1, p, ref, scale, style_height;
      scale = h / this.graph_canvas.height;
      ref = this.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        p.scale_height(scale);
      }
      style_height = h + "px";
      this.graph_canvas.height = h;
      this.graph_ui_canvas.height = h;
      this.graph_wrapper.style.height = style_height;
      this.canvas_size_rule.style.height = style_height;
      this.option.canvas_height.set(h);
      return APP.prepare_imgmask_overlay();
    };

    StochasticSierpinski.prototype.resize_graph = function(w, h) {
      this.resize_graph_width(w);
      return this.resize_graph_height(h);
    };

    StochasticSierpinski.prototype.on_canvas_width_change = function() {
      this.resize_graph_width(this.option.canvas_width.value);
      return this.resumable_reset();
    };

    StochasticSierpinski.prototype.on_canvas_height_change = function() {
      this.resize_graph_height(this.option.canvas_height.value);
      return this.resumable_reset();
    };

    StochasticSierpinski.prototype.attach_point = function(point) {
      this.points.push(point);
      return this.cur.update_point_list_metadata();
    };

    StochasticSierpinski.prototype.detach_point = function(point) {
      var idx;
      idx = this.points.indexOf(point);
      if (idx > -1) {
        this.points.splice(idx, 1);
        this.cur.update_point_list_metadata();
      }
      return APP.resumable_reset();
    };

    StochasticSierpinski.prototype.add_point = function() {
      if (this.points.length < APP.MAX_POINTS) {
        PointWidget.create();
        return this.resumable_reset();
      }
    };

    StochasticSierpinski.prototype.remove_point = function() {
      var len;
      len = this.points.length;
      if (len > APP.MIN_POINTS) {
        return this.points[len - 1].destroy();
      }
    };

    StochasticSierpinski.prototype.set_num_points = function(n) {
      var diff, j, k, ref, ref1;
      if (!(n >= this.MIN_POINTS && n <= this.MAX_POINTS)) {
        return;
      }
      diff = n - this.points.length;
      if (diff > 0) {
        for (j = 0, ref = diff; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
          this.add_point();
        }
      }
      diff = this.points.length - n;
      if (diff > 0) {
        for (k = 0, ref1 = diff; 0 <= ref1 ? k < ref1 : k > ref1; 0 <= ref1 ? k++ : k--) {
          this.remove_point();
        }
      }
      return this.num_points_el.value = this.points.length;
    };

    StochasticSierpinski.prototype.recolor_periodic_hue = function(step, start) {
      var hue, j, len1, p, ref, results;
      if (start == null) {
        start = 0.0;
      }
      hue = start;
      ref = this.points;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        p.set_color_hue(hue);
        results.push(hue += step);
      }
      return results;
    };

    StochasticSierpinski.prototype.recolor_equidistant_hue = function() {
      return this.recolor_periodic_hue(360.0 / this.points.length);
    };

    StochasticSierpinski.prototype.set_ngon = function(n, recolor) {
      if (recolor == null) {
        recolor = true;
      }
      this.set_num_points(n);
      this.on_move_all_reg_polygon();
      if (recolor) {
        return this.recolor_equidistant_hue();
      }
    };

    StochasticSierpinski.prototype.on_num_points_input = function(event) {
      return this.set_ngon(event.target.value);
    };

    StochasticSierpinski.prototype.set_all_points_move_perc = function(value) {
      var j, len1, p, ref, results;
      ref = this.points;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        results.push(p.set_move_perc(value));
      }
      return results;
    };

    StochasticSierpinski.prototype.on_steps_per_frame_input = function(event) {
      return this.set_steps_per_frame(event.target.value);
    };

    StochasticSierpinski.prototype.set_steps_per_frame = function(int_value, save_to_cookie) {
      if (save_to_cookie == null) {
        save_to_cookie = true;
      }
      this.old_steps_per_frame = this.steps_per_frame;
      this.steps_per_frame = parseInt(int_value);
      if (this.steps_per_frame < 1) {
        this.steps_per_frame = 1;
      }
      this.btn_multistep.textContent = "Step " + this.steps_per_frame + "x";
      if (this.steps_per_frame === 1) {
        this.steps_per_frame_el.value = 0;
        this.btn_multistep.disabled = true;
      } else {
        this.steps_per_frame_el.value = this.steps_per_frame;
        this.btn_multistep.disabled = false;
      }
      if (save_to_cookie) {
        if (this.old_steps_per_frame !== this.steps_per_frame) {
          return this.serialize_cookie('steps_per_frame', this.steps_per_frame);
        }
      }
    };

    StochasticSierpinski.prototype.on_create_png = function() {
      return this.open_in_new_window(this.graph_canvas.toDataURL('png'));
    };

    StochasticSierpinski.prototype.open_in_new_window = function(url) {
      return window.open(url, '_blank');
    };

    StochasticSierpinski.prototype.show_serializebox = function(title, text, action_callback) {
      this.serializebox_title.textContent = title;
      this.serializebox_action.textContent = title;
      if (text != null) {
        this.serializebox_text.value = text;
      } else {
        this.serializebox_text.value = '';
      }
      if (action_callback != null) {
        this.serializebox_action.style.display = 'inline-block';
        this.serializebox_action_callback = action_callback;
        this.serializebox_cancel.textContent = 'Cancel';
      } else {
        this.serializebox_action.style.display = 'none';
        this.serializebox_cancel.textContent = 'Close';
      }
      return this.serializebox.style.display = 'block';
    };

    StochasticSierpinski.prototype.hide_serializebox = function() {
      return this.serializebox.style.display = 'none';
    };

    StochasticSierpinski.prototype.on_serializebox_action = function() {
      if (this.serializebox_action_callback != null) {
        this.serializebox_action_callback(this.serializebox_text.value);
      }
      return this.hide_serializebox();
    };

    StochasticSierpinski.prototype.on_serializebox_cancel = function() {
      return this.hide_serializebox();
    };

    StochasticSierpinski.prototype.serialize = function() {
      var opt;
      opt = {
        points: this.points.map(function(x) {
          return x.save();
        }),
        restrictions: this.cur.restrictions.save(),
        options: {
          canvas_width: this.option.canvas_width.value,
          canvas_height: this.option.canvas_height.value,
          draw_opacity: this.option.draw_opacity.value,
          draw_style: this.cur.option.draw_style.get(),
          data_source: this.cur.option.data_source.get(),
          all_points_move_perc: this.cur.option.move_perc.get(),
          move_absolute_magnitude: this.move_absolute_magnitude,
          move_range_min: this.option.move_range_min.get(),
          move_range_max: this.option.move_range_max.get(),
          imgmask: this.cur.save_imgmask()
        }
      };
      return JSON.stringify(opt);
    };

    StochasticSierpinski.prototype.deserialize = function(text) {
      var i, j, len1, opt, p, ref;
      opt = JSON.parse(text);
      if (opt.options != null) {
        if ((opt.options.canvas_width != null) && (opt.options.canvas_width != null)) {
          this.resize_graph(opt.options.canvas_width, opt.options.canvas_width);
        }
        if (opt.options.draw_opacity != null) {
          this.option.draw_opacity.set(opt.options.draw_opacity);
        }
        if (opt.options.draw_style != null) {
          this.cur.set_draw_style(opt.options.draw_style);
        }
        if (opt.options.data_source != null) {
          this.cur.set_data_source(opt.options.data_source);
        }
        if (opt.options.move_range_min != null) {
          this.option.move_range_min.set(opt.options.move_range_min);
        }
        if (opt.options.move_range_max != null) {
          this.option.move_range_max.set(opt.options.move_range_max);
        }
        if ((opt.options.move_range_min != null) || (opt.options.move_range_max != null)) {
          this.on_move_range_change();
        }
        if (opt.options.all_points_move_perc != null) {
          this.cur.set_move_perc(opt.options.all_points_move_perc);
        }
        if (opt.options.move_absolute_magnitude != null) {
          this.move_absolute_magnitude = opt.options.move_absolute_magnitude;
        }
        if (opt.options.imgmask) {
          this.cur.load_imgmask(opt.options.imgmask);
        }
      }
      if (opt.points != null) {
        this.set_num_points(opt.points.length);
        ref = opt.points;
        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
          p = ref[i];
          this.points[i].load(p);
        }
      }
      if (opt.restrictions != null) {
        return this.cur.restrictions.load(opt.restrictions);
      }
    };

    StochasticSierpinski.prototype.on_save = function() {
      return this.show_serializebox('Save', this.serialize(), null);
    };

    StochasticSierpinski.prototype.on_load = function() {
      return this.show_serializebox('Load', null, this.deserialize);
    };

    StochasticSierpinski.prototype.on_save_url = function() {
      var hash;
      hash = this.serialize();
      return document.location = "#" + hash;
    };

    StochasticSierpinski.prototype.on_move_all_reg_polygon = function() {
      var cx, cy, height, i, j, len, len1, maxx, maxy, mincxy, minside, p, r, ref, ref1, rotate, side, theta, tri_adj, x, y;
      len = this.points.length;
      ref = this.max_xy(), maxx = ref[0], maxy = ref[1];
      minside = Math.min(maxx, maxy);
      cx = maxx / 2;
      cy = maxy / 2;
      mincxy = Math.min(cx, cy);
      r = mincxy - this.REG_POLYGON_MARGIN;
      theta = (Math.PI * 2) / len;
      rotate = -Math.PI / 2;
      switch (len) {
        case 3:
          side = minside - (2 * this.REG_POLYGON_MARGIN);
          height = side * (Math.sqrt(3) / 2);
          tri_adj = (minside - height) / 2;
          cy += tri_adj * 1.5;
          r *= 1.12;
          break;
        case 4:
          rotate += Math.PI / 4;
          r = Math.sqrt((r * r) * 2);
      }
      ref1 = this.points;
      for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
        p = ref1[i];
        x = parseInt(r * Math.cos(rotate + theta * i));
        y = parseInt(r * Math.sin(rotate + theta * i));
        p.move(cx + x, cy + y);
      }
      return this.resumable_reset();
    };

    StochasticSierpinski.prototype.on_move_all_random = function() {
      var j, len1, p, ref;
      ref = this.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        p.move(this.random_x(), this.random_y());
      }
      return this.resumable_reset();
    };

    StochasticSierpinski.prototype.random_x = function() {
      return parseInt(Math.random() * this.graph_ui_canvas.width);
    };

    StochasticSierpinski.prototype.random_y = function() {
      return parseInt(Math.random() * this.graph_ui_canvas.height);
    };

    StochasticSierpinski.prototype.max_xy = function() {
      return [this.graph_ui_canvas.width, this.graph_ui_canvas.height];
    };

    StochasticSierpinski.prototype.update_info_elements = function() {
      var ref;
      this.total_steps_cell.textContent = this.step_count;
      return (ref = this.cur) != null ? ref.update_text() : void 0;
    };

    StochasticSierpinski.prototype.event_to_canvas_loc = function(event) {
      return {
        x: event.layerX,
        y: event.layerY
      };
    };

    StochasticSierpinski.prototype.is_inside_ui = function(loc) {
      var ref, ref1;
      return ((0 <= (ref = loc.x) && ref <= this.graph_ui_canvas.width)) && ((0 <= (ref1 = loc.y) && ref1 <= this.graph_ui_canvas.height));
    };

    StochasticSierpinski.prototype.nearby_points = function(loc) {
      return this.points.filter((function(_this) {
        return function(p) {
          return p.distance(loc) < _this.NEARBY_RADIUS;
        };
      })(this));
    };

    StochasticSierpinski.prototype.first_nearby_point = function(loc) {
      var nearlist;
      nearlist = this.nearby_points(loc);
      if (nearlist != null) {
        return nearlist[0];
      } else {
        return null;
      }
    };

    StochasticSierpinski.prototype.unhighlight_all = function() {
      var changed, j, len1, p, ref;
      changed = false;
      ref = this.points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        p = ref[j];
        if (p.unhighlight()) {
          changed = true;
        }
      }
      return changed;
    };

    StochasticSierpinski.prototype.get_overlay_highlight_dnd_handler = function(side) {
      switch (side) {
        case 'left':
          return new XOffsetDNDHandler('imgmask_offset_x');
        case 'top':
          return new YOffsetDNDHandler('imgmask_offset_y');
        case 'right':
          return new ScaleWidthDNDHandler('imgmask_scale_width');
        case 'bottom':
          return new ScaleHeightDNDHandler('imgmask_scale_height');
        case 'TL':
          return new MultiDNDHandler(new XOffsetDNDHandler('imgmask_offset_x', false), new YOffsetDNDHandler('imgmask_offset_y', false));
        case 'BR':
          return new MultiDNDHandler(new ScaleWidthDNDHandler('imgmask_scale_width', false), new ScaleHeightDNDHandler('imgmask_scale_height', false));
        default:
          return null;
      }
    };

    StochasticSierpinski.prototype.on_mousedown = function(event) {
      var loc, p;
      if (this.dnd_target != null) {
        if (this.dnd_target.commit != null) {
          this.dnd_target.commit();
        }
        this.dnd_target = null;
      }
      this.unhighlight_all();
      loc = this.event_to_canvas_loc(event);
      p = this.first_nearby_point(loc);
      if (p != null) {
        this.dnd_target = p;
        return p.highlight();
      } else {
        if (this.enable_imgmask_dnd) {
          this.find_nearby_imgmask_highlight(loc.x, loc.y, false);
          if (this.imgmask_overlay_highlight != null) {
            return this.dnd_target = this.get_overlay_highlight_dnd_handler(this.imgmask_overlay_highlight);
          } else {

          }
        }
      }
    };

    StochasticSierpinski.prototype.on_mouseup = function(event) {
      var loc;
      if (this.dnd_target != null) {
        loc = this.event_to_canvas_loc(event);
        if (this.is_inside_ui(loc)) {
          this.dnd_target.move(loc.x, loc.y);
          if (this.dnd_target.commit != null) {
            this.dnd_target.commit();
          }
          this.redraw_ui();
          this.resumable_reset();
        } else {

        }
        return this.dnd_target = null;
      } else {

      }
    };

    StochasticSierpinski.prototype.on_mousemove = function(event) {
      var loc, p, redraw;
      loc = this.event_to_canvas_loc(event);
      if (this.dnd_target != null) {
        if (this.is_inside_ui(loc)) {
          this.dnd_target.move(loc.x, loc.y);
          return this.redraw_ui(false);
        }
      } else {
        redraw = this.unhighlight_all();
        p = this.first_nearby_point(loc);
        if (p != null) {
          if (p.highlight()) {
            redraw = true;
          }
        }
        if (this.enable_imgmask_dnd) {
          if (this.find_nearby_imgmask_highlight(loc.x, loc.y, false)) {
            redraw = true;
          }
        }
        if (redraw) {
          return this.redraw_ui();
        } else {

        }
      }
    };

    StochasticSierpinski.prototype.find_nearby_imgmask_highlight = function(mx, my, redraw_on_change) {
      var bsize, esize, oldhighlight;
      if (redraw_on_change == null) {
        redraw_on_change = true;
      }
      oldhighlight = this.imgmask_overlay_highlight;
      esize = 6;
      bsize = 8;
      if (((this.image_edge_x - bsize) < mx && mx < (this.image_edge_x + bsize)) && ((this.image_edge_y - bsize) < my && my < (this.image_edge_y + bsize))) {
        this.imgmask_overlay_highlight = 'TL';
      } else if (((this.image_faredge_x - bsize) < mx && mx < (this.image_faredge_x + bsize)) && ((this.image_faredge_y - bsize) < my && my < (this.image_faredge_y + bsize))) {
        this.imgmask_overlay_highlight = 'BR';
      } else if ((this.image_edge_x < mx && mx < this.image_faredge_x) && ((this.image_edge_y - esize) < my && my < (this.image_edge_y + esize))) {
        this.imgmask_overlay_highlight = 'top';
      } else if ((this.image_edge_y < my && my < this.image_faredge_y) && ((this.image_edge_x - esize) < mx && mx < (this.image_edge_x + esize))) {
        this.imgmask_overlay_highlight = 'left';
      } else if ((this.image_edge_x < mx && mx < this.image_faredge_x) && ((this.image_faredge_y - esize) < my && my < (this.image_faredge_y + esize))) {
        this.imgmask_overlay_highlight = 'bottom';
      } else if ((this.image_edge_y < my && my < this.image_faredge_y) && ((this.image_faredge_x - esize) < mx && mx < (this.image_faredge_x + esize))) {
        this.imgmask_overlay_highlight = 'right';
      } else {
        this.imgmask_overlay_highlight = null;
      }
      if (oldhighlight !== this.imgmask_overlay_highlight) {
        return true;
      } else {
        return false;
      }
    };

    StochasticSierpinski.prototype.resumable_reset = function() {
      return this.on_reset(true);
    };

    StochasticSierpinski.prototype.update_metadata_and_reset = function() {
      var ref;
      if ((ref = this.cur) != null) {
        ref.update_point_list_metadata();
      }
      return this.on_reset(true);
    };

    StochasticSierpinski.prototype.clear_graph_canvas = function() {
      this.graph_ctx.clearRect(0, 0, this.graph_canvas.width, this.graph_canvas.height);
      this.graph_ctx.fillStyle = '#fff';
      return this.graph_ctx.fillRect(0, 0, this.graph_canvas.width, this.graph_canvas.height);
    };

    StochasticSierpinski.prototype.on_reset = function(restart_ok) {
      var was_running;
      if (restart_ok == null) {
        restart_ok = false;
      }
      was_running = this.running;
      this.stop();
      if (this.cur != null) {
        this.cur.move(this.graph_ui_canvas.width / 2, this.graph_ui_canvas.height / 2);
        this.cur.reset_color_cache();
      }
      this.step_count = 0;
      this.clear_update_and_draw();
      if (restart_ok && was_running) {
        return this.start();
      }
    };

    StochasticSierpinski.prototype.on_step = function() {
      if (this.running) {
        return this.stop();
      } else {
        return this.step();
      }
    };

    StochasticSierpinski.prototype.on_multistep = function() {
      if (this.running) {
        return this.stop();
      } else {
        return this.multistep();
      }
    };

    StochasticSierpinski.prototype.on_run = function() {
      if (this.running) {
        return this.stop();
      } else {
        return this.start();
      }
    };

    StochasticSierpinski.prototype.start = function() {
      this.running = true;
      this.btn_run.textContent = 'Pause';
      this.btn_run.classList.remove('paused');
      this.btn_run.classList.add('running');
      return this.schedule_next_frame();
    };

    StochasticSierpinski.prototype.stop = function() {
      this.running = false;
      this.btn_run.textContent = 'Run';
      this.btn_run.classList.remove('running');
      return this.btn_run.classList.add('paused');
    };

    StochasticSierpinski.prototype.single_step = function() {
      if (this.cur.single_step()) {
        this.step_count += 1;
        return true;
      } else {
        return false;
      }
    };

    StochasticSierpinski.prototype.step = function() {
      this.single_step();
      this.update_info_elements();
      this.redraw_ui();
      return null;
    };

    StochasticSierpinski.prototype.multistep = function() {
      var j, ref;
      for (j = 0, ref = this.steps_per_frame; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--) {
        if (!this.single_step()) {
          if (this.running) {
            this.stop();
          }
          console.log('forced stop!');
          break;
        }
      }
      this.update_info_elements();
      this.redraw_ui();
      return null;
    };

    StochasticSierpinski.prototype.prepare_imgmask_overlay = function() {
      var ch, cw, hch, hcw, scaled_half_height, scaled_half_width;
      if (this.cur == null) {
        return;
      }
      cw = this.graph_ui_canvas.width;
      ch = this.graph_ui_canvas.height;
      hcw = cw / 2;
      hch = ch / 2;
      scaled_half_width = Math.floor(hcw * (this.cur.option.imgmask_scale_width.get() / 100));
      scaled_half_height = Math.floor(hch * (this.cur.option.imgmask_scale_height.get() / 100));
      this.image_width = 2 * scaled_half_width;
      this.image_height = 2 * scaled_half_height;
      this.image_edge_x = hcw - scaled_half_width;
      this.image_edge_y = hch - scaled_half_height;
      this.image_edge_x += this.cur.option.imgmask_offset_x.get();
      this.image_edge_y += this.cur.option.imgmask_offset_y.get();
      this.image_faredge_x = this.image_edge_x + this.image_width;
      return this.image_faredge_y = this.image_edge_y + this.image_height;
    };

    StochasticSierpinski.prototype.render_imgmask_overlay = function(render_bitmap_preview) {
      if (render_bitmap_preview == null) {
        render_bitmap_preview = true;
      }
      this.prepare_imgmask_overlay();
      if (this.cur.imgmask_img_ready && (render_bitmap_preview != null)) {
        this.render_overlay_bitmap_preview();
      }
      this.render_overlay_margin_shading();
      if (this.enable_imgmask_dnd && (this.imgmask_overlay_highlight != null)) {
        return this.render_overlay_highlight();
      }
    };

    StochasticSierpinski.prototype.render_overlay_bitmap_preview = function() {
      var oldalpha;
      this.graph_ui_ctx.save();
      oldalpha = this.graph_ui_ctx.globalAlpha;
      this.graph_ui_ctx.globalAlpha = 0.5;
      this.graph_ui_ctx.drawImage(this.cur.imgmask_bitmap, 0, 0, this.cur.imgmask_bitmap.width, this.cur.imgmask_bitmap.height, this.cur.imgmask_offset_x, this.cur.imgmask_offset_y, this.graph_ui_canvas.width, this.graph_ui_canvas.height);
      this.graph_ui_ctx.globalAlpha = oldalpha;
      return this.graph_ui_ctx.restore();
    };

    StochasticSierpinski.prototype.render_overlay_margin_shading = function() {
      var img_region;
      this.graph_ui_ctx.save();
      img_region = new Path2D();
      img_region.rect(this.image_edge_x, this.image_edge_y, this.image_width, this.image_height);
      img_region.rect(0, 0, this.graph_ui_canvas.width, this.graph_ui_canvas.height);
      this.graph_ui_ctx.clip(img_region, 'evenodd');
      this.graph_ui_ctx.fillStyle = 'rgba(255, 65, 2, 0.2)';
      this.graph_ui_ctx.fillRect(0, 0, this.graph_ui_canvas.width, this.graph_ui_canvas.height);
      return this.graph_ui_ctx.restore();
    };

    StochasticSierpinski.prototype.render_overlay_highlight = function() {
      var biglinewidth, cb_margin, cb_offset, cornerbox_size, draw, dx, dy, extralinewidth, hl_bottom, hl_left, hl_right, hl_top, linetrim, linewidth, min_delta;
      linewidth = 3;
      extralinewidth = 2;
      biglinewidth = linewidth + extralinewidth;
      linetrim = biglinewidth + 4;
      cornerbox_size = 2 * linetrim;
      dx = this.image_faredge_x - this.image_edge_x;
      dy = this.image_faredge_y - this.image_edge_y;
      min_delta = Math.min(dx, dy);
      if (linetrim > min_delta) {
        linetrim = min_delta;
      }
      cb_offset = 8;
      cb_margin = 3;
      draw = null;
      hl_top = false;
      hl_left = false;
      hl_bottom = false;
      hl_right = false;
      switch (this.imgmask_overlay_highlight) {
        case 'TL':
          draw = 'TL';
          hl_top = true;
          hl_left = true;
          break;
        case 'BR':
          draw = 'BR';
          hl_bottom = true;
          hl_right = true;
          break;
        case 'top':
          draw = 'TL';
          hl_top = true;
          break;
        case 'left':
          draw = 'TL';
          hl_left = true;
          break;
        case 'bottom':
          draw = 'BR';
          hl_bottom = true;
          break;
        case 'right':
          draw = 'BR';
          hl_right = true;
          break;
        default:
          console.log('bad @imgmask_overlay_highlight value', this.imgmask_overlay_highlight);
          return;
      }
      this.graph_ui_ctx.save();
      this.graph_ui_ctx.beginPath();
      switch (draw) {
        case 'TL':
          this.graph_ui_ctx.moveTo(this.image_faredge_x - linetrim, this.image_edge_y);
          this.graph_ui_ctx.lineTo(this.image_edge_x, this.image_edge_y);
          this.graph_ui_ctx.lineTo(this.image_edge_x, this.image_faredge_y - linetrim);
          break;
        case 'BR':
          this.graph_ui_ctx.moveTo(this.image_edge_x + linetrim, this.image_faredge_y);
          this.graph_ui_ctx.lineTo(this.image_faredge_x, this.image_faredge_y);
          this.graph_ui_ctx.lineTo(this.image_faredge_x, this.image_edge_y + linetrim);
      }
      this.graph_ui_ctx.lineCap = 'round';
      this.graph_ui_ctx.lineJoin = 'round';
      this.graph_ui_ctx.strokeStyle = '#000';
      this.graph_ui_ctx.lineWidth = linewidth + extralinewidth;
      this.graph_ui_ctx.stroke();
      this.graph_ui_ctx.beginPath();
      this.graph_ui_ctx.lineCap = 'none';
      this.graph_ui_ctx.lineJoin = 'miter';
      this.graph_ui_ctx.strokeStyle = '#FFFF00';
      this.graph_ui_ctx.lineWidth = linewidth;
      this.graph_ui_ctx.setLineDash([3, 5]);
      if (hl_top) {
        this.graph_ui_ctx.moveTo(this.image_faredge_x - linetrim, this.image_edge_y);
        this.graph_ui_ctx.lineTo(this.image_edge_x + linetrim, this.image_edge_y);
        this.graph_ui_ctx.stroke();
      }
      if (hl_left) {
        this.graph_ui_ctx.moveTo(this.image_edge_x, this.image_faredge_y - linetrim);
        this.graph_ui_ctx.lineTo(this.image_edge_x, this.image_edge_y + linetrim);
        this.graph_ui_ctx.stroke();
      }
      if (hl_bottom) {
        this.graph_ui_ctx.moveTo(this.image_edge_x + linetrim, this.image_faredge_y);
        this.graph_ui_ctx.lineTo(this.image_faredge_x - linetrim, this.image_faredge_y);
        this.graph_ui_ctx.stroke();
      }
      if (hl_right) {
        this.graph_ui_ctx.moveTo(this.image_faredge_x, this.image_edge_y + linetrim);
        this.graph_ui_ctx.lineTo(this.image_faredge_x, this.image_faredge_y - linetrim);
        this.graph_ui_ctx.stroke();
      }
      this.render_overlay_cornerbox(draw, cornerbox_size, cb_offset, '#000');
      if (this.imgmask_overlay_highlight === 'TL' || this.imgmask_overlay_highlight === 'BR') {
        this.render_overlay_cornerbox(draw, cornerbox_size - (2 * cb_margin), cb_offset - cb_margin, '#FFFF00');
      }
      return this.graph_ui_ctx.restore();
    };

    StochasticSierpinski.prototype.render_overlay_cornerbox = function(draw, size, offset, style) {
      var x, y;
      this.graph_ui_ctx.beginPath();
      switch (draw) {
        case 'TL':
          x = this.image_edge_x - offset;
          y = this.image_edge_y - offset;
          this.graph_ui_ctx.rect(x, y, size, size);
          break;
        case 'BR':
          x = this.image_faredge_x + offset - size;
          y = this.image_faredge_y + offset - size;
          this.graph_ui_ctx.rect(x, y, size, size);
      }
      this.graph_ui_ctx.fillStyle = style;
      return this.graph_ui_ctx.fill();
    };

    StochasticSierpinski.prototype.redraw_ui = function(render_bitmap_preview) {
      var j, len1, p, ref, ref1;
      if (render_bitmap_preview == null) {
        render_bitmap_preview = true;
      }
      this.graph_ui_ctx.clearRect(0, 0, this.graph_ui_canvas.width, this.graph_ui_canvas.height);
      if ((ref = this.cur) != null) {
        ref.draw_ui();
      }
      ref1 = this.points;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        p = ref1[j];
        p.draw_ui();
      }
      if (this.show_imgmask_overlay || (this.enable_imgmask_dnd && this.mouse_over_graph && this.imgmask_enabled)) {
        this.render_imgmask_overlay(render_bitmap_preview);
      }
      return null;
    };

    StochasticSierpinski.prototype.update = function() {
      this.frame_is_scheduled = false;
      this.multistep();
      if (this.running) {
        this.schedule_next_frame();
      }
      return null;
    };

    StochasticSierpinski.prototype.schedule_next_frame = function() {
      if (!this.frame_is_scheduled) {
        this.frame_is_scheduled = true;
        window.requestAnimationFrame(this.update);
      }
      return null;
    };

    StochasticSierpinski.prototype.on_keydown = function(event) {
      switch (event.key) {
        case "Enter":
          return this.on_run();
        case "Escape":
        case "Esc":
          return this.stop();
        case "r":
        case "R":
          return this.resumable_reset();
        case "p":
        case "P":
          return this.on_create_png();
        case "s":
        case "S":
          return this.on_save();
        case "l":
        case "L":
          return this.on_load();
      }
    };

    StochasticSierpinski.prototype.on_hashchange = function() {
      var ref;
      if (((ref = document.location.hash) != null ? ref.length : void 0) > 1) {
        return this.deserialize(document.location.hash.slice(1));
      } else {
        return this.load_default_state();
      }
    };

    StochasticSierpinski.prototype.serialize_cookie = function(key, value) {
      return document.cookie = key + "=" + value;
    };

    StochasticSierpinski.prototype.deserialize_cookie = function(key, value) {
      switch (key) {
        case 'steps_per_frame':
          return this.set_steps_per_frame(value);
        case 'show_tooltips':
          return this.option.show_tooltips.set(value);
      }
    };

    StochasticSierpinski.prototype.load_from_cookie = function() {
      var cookie, j, len1, ref, results;
      ref = document.cookie.split('; ');
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        cookie = ref[j];
        results.push(this.deserialize_cookie.apply(this, cookie.split('=')));
      }
      return results;
    };

    return StochasticSierpinski;

  })();

  document.addEventListener('DOMContentLoaded', (function(_this) {
    return function() {
      APP = new StochasticSierpinski(document);
      APP.init();
      APP.on_hashchange();
      return APP.load_from_cookie();
    };
  })(this));

}).call(this);

    </script>
  </body>
</html>
